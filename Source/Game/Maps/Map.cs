// Copyright (c) CypherCore <http://github.com/CypherCore> All rights reserved.
// Licensed under the GNU GENERAL PUBLIC LICENSE. See LICENSE file in the project root for full license information.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using Framework.Constants;
using Framework.Database;
using Game.Collision;
using Game.DataStorage;
using Game.Entities;
using Game.Groups;
using Game.Maps.Notifiers;
using Game.Networking;
using Game.Networking.Packets;
using Game.Scripting.Interfaces.IMap;
using Game.Scripting.Interfaces.IPlayer;
using Game.Scripting.Interfaces.IWorldState;

namespace Game.Maps
{
    public class Map : IDisposable
    {
        public Map(uint id, long expiry, uint instanceId, Difficulty spawnmode)
        {
            i_mapRecord = CliDB.MapStorage.LookupByKey(id);
            i_spawnMode = spawnmode;
            i_InstanceId = instanceId;
            _VisibleDistance = SharedConst.DefaultVisibilityDistance;
            _VisibilityNotifyPeriod = SharedConst.DefaultVisibilityNotifyPeriod;
            i_gridExpiry = expiry;
            _terrain = Global.TerrainMgr.LoadTerrain(id);

            for (uint x = 0; x < MapConst.MaxGrids; ++x)
            {
                i_grids[x] = new Grid[MapConst.MaxGrids];

                for (uint y = 0; y < MapConst.MaxGrids; ++y)
                    //z code
                    SetGrid(null, x, y);
            }

            _zonePlayerCountMap.Clear();

            //lets initialize visibility distance for map
            InitVisibilityDistance();
            _weatherUpdateTimer = new IntervalTimer();
            _weatherUpdateTimer.SetInterval(1 * Time.InMilliseconds);

            GetGuidSequenceGenerator(HighGuid.Transport).Set(Global.ObjectMgr.GetGenerator(HighGuid.Transport).GetNextAfterMaxUsed());

            _poolData = Global.PoolMgr.InitPoolsForMap(this);

            Global.TransportMgr.CreateTransportsForMap(this);

            Global.MMapMgr.LoadMapInstance(Global.WorldMgr.GetDataPath(), GetId(), i_InstanceId);

            _worldStateValues = Global.WorldStateMgr.GetInitialWorldStatesForMap(this);

            Global.OutdoorPvPMgr.CreateOutdoorPvPForMap(this);
            Global.BattleFieldMgr.CreateBattlefieldsForMap(this);

            OnCreateMap(this);
        }

        public void Dispose()
        {
            OnDestroyMap(this);

            // Delete all waiting spawns
            // This doesn't delete from database.
            UnloadAllRespawnInfos();

            for (var i = 0; i < i_worldObjects.Count; ++i)
            {
                WorldObject obj = i_worldObjects[i];
                Cypher.Assert(obj.IsWorldObject());
                obj.RemoveFromWorld();
                obj.ResetMap();
            }

            if (!_scriptSchedule.Empty())
                Global.MapMgr.DecreaseScheduledScriptCount((uint)_scriptSchedule.Count);

            Global.OutdoorPvPMgr.DestroyOutdoorPvPForMap(this);
            Global.BattleFieldMgr.DestroyBattlefieldsForMap(this);

            Global.MMapMgr.UnloadMapInstance(GetId(), i_InstanceId);
        }

        public void LoadAllCells()
        {
            for (uint cellX = 0; cellX < MapConst.TotalCellsPerMap; cellX++)
                for (uint cellY = 0; cellY < MapConst.TotalCellsPerMap; cellY++)
                    LoadGrid((cellX + 0.5f - MapConst.CenterGridCellId) * MapConst.SizeofCells, (cellY + 0.5f - MapConst.CenterGridCellId) * MapConst.SizeofCells);
        }

        public virtual void InitVisibilityDistance()
        {
            //init visibility for continents
            _VisibleDistance = Global.WorldMgr.GetMaxVisibleDistanceOnContinents();
            _VisibilityNotifyPeriod = Global.WorldMgr.GetVisibilityNotifyPeriodOnContinents();
        }

        public void AddToGrid<T>(T obj, Cell cell) where T : WorldObject
        {
            Grid grid = GetGrid(cell.GetGridX(), cell.GetGridY());

            switch (obj.GetTypeId())
            {
                case TypeId.Corpse:
                    if (grid.IsGridObjectDataLoaded())
                    {
                        // Corpses are a special object Type - they can be added to grid via a call to AddToMap
                        // or loaded through ObjectGridLoader.
                        // Both corpses loaded from database and these freshly generated by Player::CreateCoprse are added to _corpsesByCell
                        // ObjectGridLoader loads all corpses from _corpsesByCell even if they were already added to grid before it was loaded
                        // so we need to explicitly check it here (Map::AddToGrid is only called from Player::BuildPlayerRepop, not from ObjectGridLoader)
                        // to avoid failing an assertion in GridObject::AddToGrid
                        if (obj.IsWorldObject())
                        {
                            obj.SetCurrentCell(cell);
                            grid.GetGridCell(cell.GetCellX(), cell.GetCellY()).AddWorldObject(obj);
                        }
                        else
                        {
                            grid.GetGridCell(cell.GetCellX(), cell.GetCellY()).AddGridObject(obj);
                        }
                    }

                    return;
                case TypeId.GameObject:
                case TypeId.AreaTrigger:
                    grid.GetGridCell(cell.GetCellX(), cell.GetCellY()).AddGridObject(obj);

                    break;
                case TypeId.DynamicObject:
                default:
                    if (obj.IsWorldObject())
                        grid.GetGridCell(cell.GetCellX(), cell.GetCellY()).AddWorldObject(obj);
                    else
                        grid.GetGridCell(cell.GetCellX(), cell.GetCellY()).AddGridObject(obj);

                    break;
            }

            obj.SetCurrentCell(cell);
        }

        public void RemoveFromGrid(WorldObject obj, Cell cell)
        {
            if (cell == null)
                return;

            Grid grid = GetGrid(cell.GetGridX(), cell.GetGridY());

            if (grid == null)
                return;

            if (obj.IsWorldObject())
                grid.GetGridCell(cell.GetCellX(), cell.GetCellY()).RemoveWorldObject(obj);
            else
                grid.GetGridCell(cell.GetCellX(), cell.GetCellY()).RemoveGridObject(obj);

            obj.SetCurrentCell(null);
        }

        public virtual void LoadGridObjects(Grid grid, Cell cell)
        {
            ObjectGridLoader loader = new(grid, this, cell);
            loader.LoadN();
        }

        public void LoadGrid(float x, float y)
        {
            EnsureGridLoaded(new Cell(x, y));
        }

        public void LoadGridForActiveObject(float x, float y, WorldObject obj)
        {
            EnsureGridLoadedForActiveObject(new Cell(x, y), obj);
        }

        public virtual bool AddPlayerToMap(Player player, bool initPlayer = true)
        {
            CellCoord cellCoord = GridDefines.ComputeCellCoord(player.GetPositionX(), player.GetPositionY());

            if (!cellCoord.IsCoordValid())
            {
                Log.outError(LogFilter.Maps,
                             "Map.AddPlayer (GUID: {0}) has invalid coordinates X:{1} Y:{2}",
                             player.GetGUID().ToString(),
                             player.GetPositionX(),
                             player.GetPositionY());

                return false;
            }

            var cell = new Cell(cellCoord);
            EnsureGridLoadedForActiveObject(cell, player);
            AddToGrid(player, cell);

            Cypher.Assert(player.GetMap() == this);
            player.SetMap(this);
            player.AddToWorld();

            if (initPlayer)
                SendInitSelf(player);

            SendInitTransports(player);

            if (initPlayer)
                player.ClientGUIDs.Clear();

            player.UpdateObjectVisibility(false);
            PhasingHandler.SendToPlayer(player);

            if (player.IsAlive())
                ConvertCorpseToBones(player.GetGUID());

            _activePlayers.Add(player);

            OnPlayerEnterMap(this, player);

            return true;
        }

        public void UpdatePersonalPhasesForPlayer(Player player)
        {
            Cell cell = new(player.GetPositionX(), player.GetPositionY());
            GetMultiPersonalPhaseTracker().OnOwnerPhaseChanged(player, GetGrid(cell.GetGridX(), cell.GetGridY()), this, cell);
        }

        public int GetWorldStateValue(int worldStateId)
        {
            return _worldStateValues.LookupByKey(worldStateId);
        }

        public Dictionary<int, int> GetWorldStateValues()
        {
            return _worldStateValues;
        }

        public void SetWorldStateValue(int worldStateId, int value, bool hidden)
        {
            int oldValue = 0;

            if (!_worldStateValues.TryAdd(worldStateId, 0))
            {
                oldValue = _worldStateValues[worldStateId];

                if (oldValue == value)
                    return;
            }

            _worldStateValues[worldStateId] = value;

            WorldStateTemplate worldStateTemplate = Global.WorldStateMgr.GetWorldStateTemplate(worldStateId);

            if (worldStateTemplate != null)
                Global.ScriptMgr.RunScript<IWorldStateOnValueChange>(script => script.OnValueChange(worldStateTemplate.Id, oldValue, value, this), worldStateTemplate.ScriptId);

            // Broadcast update to all players on the map
            UpdateWorldState updateWorldState = new();
            updateWorldState.VariableID = (uint)worldStateId;
            updateWorldState.Value = value;
            updateWorldState.Hidden = hidden;
            updateWorldState.Write();

            foreach (var player in GetPlayers())
            {
                if (worldStateTemplate != null &&
                    !worldStateTemplate.AreaIds.Empty())
                {
                    bool isInAllowedArea = worldStateTemplate.AreaIds.Any(requiredAreaId => Global.DB2Mgr.IsInArea(player.GetAreaId(), requiredAreaId));

                    if (!isInAllowedArea)
                        continue;
                }

                player.SendPacket(updateWorldState);
            }
        }

        public bool AddToMap(WorldObject obj)
        {
            //TODO: Needs clean up. An object should not be added to map twice.
            if (obj.IsInWorld)
            {
                obj.UpdateObjectVisibility(true);

                return true;
            }

            CellCoord cellCoord = GridDefines.ComputeCellCoord(obj.GetPositionX(), obj.GetPositionY());

            if (!cellCoord.IsCoordValid())
            {
                Log.outError(LogFilter.Maps,
                             "Map.Add: Object {0} has invalid coordinates X:{1} Y:{2} grid cell [{3}:{4}]",
                             obj.GetGUID(),
                             obj.GetPositionX(),
                             obj.GetPositionY(),
                             cellCoord.X_coord,
                             cellCoord.Y_coord);

                return false; //Should delete object
            }

            var cell = new Cell(cellCoord);

            if (obj.IsActiveObject())
                EnsureGridLoadedForActiveObject(cell, obj);
            else
                EnsureGridCreated(new GridCoord(cell.GetGridX(), cell.GetGridY()));

            AddToGrid(obj, cell);
            Log.outDebug(LogFilter.Maps, "Object {0} enters grid[{1}, {2}]", obj.GetGUID().ToString(), cell.GetGridX(), cell.GetGridY());

            obj.AddToWorld();

            InitializeObject(obj);

            if (obj.IsActiveObject())
                AddToActive(obj);

            //something, such as vehicle, needs to be update immediately
            //also, trigger needs to cast spell, if not update, cannot see visual
            obj.SetIsNewObject(true);
            obj.UpdateObjectVisibilityOnCreate();
            obj.SetIsNewObject(false);

            return true;
        }

        public bool AddToMap(Transport obj)
        {
            //TODO: Needs clean up. An object should not be added to map twice.
            if (obj.IsInWorld)
                return true;

            CellCoord cellCoord = GridDefines.ComputeCellCoord(obj.GetPositionX(), obj.GetPositionY());

            if (!cellCoord.IsCoordValid())
            {
                Log.outError(LogFilter.Maps,
                             "Map.Add: Object {0} has invalid coordinates X:{1} Y:{2} grid cell [{3}:{4}]",
                             obj.GetGUID(),
                             obj.GetPositionX(),
                             obj.GetPositionY(),
                             cellCoord.X_coord,
                             cellCoord.Y_coord);

                return false; //Should delete object
            }

            _transports.Add(obj);

            if (obj.GetExpectedMapId() == GetId())
            {
                obj.AddToWorld();

                // Broadcast creation to players
                foreach (var player in GetPlayers())
                    if (player.GetTransport() != obj &&
                        player.InSamePhase(obj))
                    {
                        var data = new UpdateData(GetId());
                        obj.BuildCreateUpdateBlockForPlayer(data, player);
                        player.VisibleTransports.Add(obj.GetGUID());
                        UpdateObject packet;
                        data.BuildPacket(out packet);
                        player.SendPacket(packet);
                    }
            }

            return true;
        }

        public bool IsGridLoaded(uint gridId)
        {
            return IsGridLoaded(new GridCoord(gridId % MapConst.MaxGrids, gridId / MapConst.MaxGrids));
        }

        public bool IsGridLoaded(float x, float y)
        {
            return IsGridLoaded(GridDefines.ComputeGridCoord(x, y));
        }

        public bool IsGridLoaded(Position pos)
        {
            return IsGridLoaded(pos.GetPositionX(), pos.GetPositionY());
        }

        public bool IsGridLoaded(GridCoord p)
        {
            return (GetGrid(p.X_coord, p.Y_coord) != null && IsGridObjectDataLoaded(p.X_coord, p.Y_coord));
        }

        public void UpdatePlayerZoneStats(uint oldZone, uint newZone)
        {
            // Nothing to do if no change
            if (oldZone == newZone)
                return;

            if (oldZone != MapConst.InvalidZone)
            {
                Cypher.Assert(_zonePlayerCountMap[oldZone] != 0, $"A player left zone {oldZone} (went to {newZone}) - but there were no players in the zone!");
                --_zonePlayerCountMap[oldZone];
            }

            if (!_zonePlayerCountMap.ContainsKey(newZone))
                _zonePlayerCountMap[newZone] = 0;

            ++_zonePlayerCountMap[newZone];
        }

        public virtual void Update(uint diff)
        {
            _dynamicTree.Update(diff);

            // update worldsessions for existing players
            for (var i = 0; i < _activePlayers.Count; ++i)
            {
                Player player = _activePlayers[i];

                if (player.IsInWorld)
                {
                    WorldSession session = player.Session;
                    var updater = new MapSessionFilter(session);
                    session.Update(diff, updater);
                }
            }

            /// process any due respawns
            if (_respawnCheckTimer <= diff)
            {
                ProcessRespawns();
                UpdateSpawnGroupConditions();
                _respawnCheckTimer = WorldConfig.GetUIntValue(WorldCfg.RespawnMinCheckIntervalMs);
            }
            else
            {
                _respawnCheckTimer -= diff;
            }

            // update active cells around players and active objects
            ResetMarkedCells();

            var update = new UpdaterNotifier(diff);

            var grid_object_update = new Visitor(update, GridMapTypeMask.AllGrid);
            var world_object_update = new Visitor(update, GridMapTypeMask.AllWorld);

            for (var i = 0; i < _activePlayers.Count; ++i)
            {
                Player player = _activePlayers[i];

                if (!player.IsInWorld)
                    continue;

                // update players at tick
                player.Update(diff);

                VisitNearbyCellsOf(player, grid_object_update, world_object_update);

                // If player is using far sight or mind vision, visit that object too
                WorldObject viewPoint = player.GetViewpoint();

                if (viewPoint)
                    VisitNearbyCellsOf(viewPoint, grid_object_update, world_object_update);

                // Handle updates for creatures in combat with player and are more than 60 yards away
                if (player.IsInCombat())
                {
                    List<Unit> toVisit = new();

                    foreach (var pair in player.GetCombatManager().GetPvECombatRefs())
                    {
                        Creature unit = pair.Value.GetOther(player).ToCreature();

                        if (unit != null)
                            if (unit.GetMapId() == player.GetMapId() &&
                                !unit.IsWithinDistInMap(player, GetVisibilityRange(), false))
                                toVisit.Add(unit);
                    }

                    foreach (Unit unit in toVisit)
                        VisitNearbyCellsOf(unit, grid_object_update, world_object_update);
                }

                {
                    // Update any creatures that own Auras the player has applications of
                    List<Unit> toVisit = new();

                    foreach (var pair in player.GetAppliedAuras())
                    {
                        Unit caster = pair.Value.GetBase().GetCaster();

                        if (caster != null)
                            if (!caster.IsPlayer() &&
                                !caster.IsWithinDistInMap(player, GetVisibilityRange(), false))
                                toVisit.Add(caster);
                    }

                    foreach (Unit unit in toVisit)
                        VisitNearbyCellsOf(unit, grid_object_update, world_object_update);
                }

                {
                    // Update player's summons
                    List<Unit> toVisit = new();

                    // Totems
                    foreach (ObjectGuid summonGuid in player.SummonSlot)
                        if (!summonGuid.IsEmpty())
                        {
                            Creature unit = GetCreature(summonGuid);

                            if (unit != null)
                                if (unit.GetMapId() == player.GetMapId() &&
                                    !unit.IsWithinDistInMap(player, GetVisibilityRange(), false))
                                    toVisit.Add(unit);
                        }

                    foreach (Unit unit in toVisit)
                        VisitNearbyCellsOf(unit, grid_object_update, world_object_update);
                }
            }

            for (var i = 0; i < _activeNonPlayers.Count; ++i)
            {
                WorldObject obj = _activeNonPlayers[i];

                if (!obj.IsInWorld)
                    continue;

                VisitNearbyCellsOf(obj, grid_object_update, world_object_update);
            }

            for (var i = 0; i < _transports.Count; ++i)
            {
                Transport transport = _transports[i];

                if (!transport)
                    continue;

                transport.Update(diff);
            }

            SendObjectUpdates();

            // Process necessary scripts
            if (!_scriptSchedule.Empty())
            {
                i_scriptLock = true;
                ScriptsProcess();
                i_scriptLock = false;
            }

            _weatherUpdateTimer.Update(diff);

            if (_weatherUpdateTimer.Passed())
            {
                foreach (var zoneInfo in _zoneDynamicInfo)
                    if (zoneInfo.Value.DefaultWeather != null &&
                        !zoneInfo.Value.DefaultWeather.Update((uint)_weatherUpdateTimer.GetInterval()))
                        zoneInfo.Value.DefaultWeather = null;

                _weatherUpdateTimer.Reset();
            }

            // update phase shift objects
            GetMultiPersonalPhaseTracker().Update(this, diff);

            MoveAllCreaturesInMoveList();
            MoveAllGameObjectsInMoveList();
            MoveAllAreaTriggersInMoveList();

            if (!_activePlayers.Empty() ||
                !_activeNonPlayers.Empty())
                ProcessRelocationNotifies(diff);

            OnMapUpdate(this, diff);
        }

        public virtual void RemovePlayerFromMap(Player player, bool remove)
        {
            // Before leaving map, update zone/area for Stats
            player.UpdateZone(MapConst.InvalidZone, 0);
            OnPlayerLeaveMap(this, player);

            GetMultiPersonalPhaseTracker().MarkAllPhasesForDeletion(player.GetGUID());

            player.CombatStop();

            bool inWorld = player.IsInWorld;
            player.RemoveFromWorld();
            SendRemoveTransports(player);

            if (!inWorld) // if was in world, RemoveFromWorld() called DestroyForNearbyPlayers()
                player.UpdateObjectVisibilityOnDestroy();

            Cell cell = player.GetCurrentCell();
            RemoveFromGrid(player, cell);

            _activePlayers.Remove(player);

            if (remove)
                DeleteFromWorld(player);
        }

        public void RemoveFromMap(WorldObject obj, bool remove)
        {
            bool inWorld = obj.IsInWorld && obj.GetTypeId() >= TypeId.Unit && obj.GetTypeId() <= TypeId.GameObject;
            obj.RemoveFromWorld();

            if (obj.IsActiveObject())
                RemoveFromActive(obj);

            GetMultiPersonalPhaseTracker().UnregisterTrackedObject(obj);

            if (!inWorld) // if was in world, RemoveFromWorld() called DestroyForNearbyPlayers()
                obj.UpdateObjectVisibilityOnDestroy();

            Cell cell = obj.GetCurrentCell();
            RemoveFromGrid(obj, cell);

            obj.ResetMap();

            if (remove)
                DeleteFromWorld(obj);
        }

        public void RemoveFromMap(Transport obj, bool remove)
        {
            if (obj.IsInWorld)
            {
                obj.RemoveFromWorld();

                UpdateData data = new(GetId());

                if (obj.IsDestroyedObject())
                    obj.BuildDestroyUpdateBlock(data);
                else
                    obj.BuildOutOfRangeUpdateBlock(data);

                UpdateObject packet;
                data.BuildPacket(out packet);

                foreach (var player in GetPlayers())
                    if (player.GetTransport() != obj &&
                        player.VisibleTransports.Contains(obj.GetGUID()))
                    {
                        player.SendPacket(packet);
                        player.VisibleTransports.Remove(obj.GetGUID());
                    }
            }

            if (!_transports.Contains(obj))
                return;

            _transports.Remove(obj);

            obj.ResetMap();

            if (remove)
                DeleteFromWorld(obj);
        }

        public void PlayerRelocation(Player player, float x, float y, float z, float orientation)
        {
            var oldcell = player.GetCurrentCell();
            var newcell = new Cell(x, y);

            player.Relocate(x, y, z, orientation);

            if (player.IsVehicle())
                player.GetVehicleKit().RelocatePassengers();

            if (oldcell.DiffGrid(newcell) ||
                oldcell.DiffCell(newcell))
            {
                Log.outDebug(LogFilter.Maps,
                             "Player {0} relocation grid[{1}, {2}]cell[{3}, {4}].grid[{5}, {6}]cell[{7}, {8}]",
                             player.GetName(),
                             oldcell.GetGridX(),
                             oldcell.GetGridY(),
                             oldcell.GetCellX(),
                             oldcell.GetCellY(),
                             newcell.GetGridX(),
                             newcell.GetGridY(),
                             newcell.GetCellX(),
                             newcell.GetCellY());

                RemoveFromGrid(player, oldcell);

                if (oldcell.DiffGrid(newcell))
                    EnsureGridLoadedForActiveObject(newcell, player);

                AddToGrid(player, newcell);
            }

            player.UpdatePositionData();
            player.UpdateObjectVisibility(false);
        }

        public void CreatureRelocation(Creature creature, float x, float y, float z, float ang, bool respawnRelocationOnFail = true)
        {
            Cypher.Assert(CheckGridIntegrity(creature, false));

            var new_cell = new Cell(x, y);

            if (!respawnRelocationOnFail &&
                GetGrid(new_cell.GetGridX(), new_cell.GetGridY()) == null)
                return;

            Cell old_cell = creature.GetCurrentCell();

            // delay creature move for grid/cell to grid/cell moves
            if (old_cell.DiffCell(new_cell) ||
                old_cell.DiffGrid(new_cell))
            {
                AddCreatureToMoveList(creature, x, y, z, ang);
                // in diffcell/diffgrid case notifiers called at finishing move creature in MoveAllCreaturesInMoveList
            }
            else
            {
                creature.Relocate(x, y, z, ang);

                if (creature.IsVehicle())
                    creature.GetVehicleKit().RelocatePassengers();

                creature.UpdateObjectVisibility(false);
                creature.UpdatePositionData();
                RemoveCreatureFromMoveList(creature);
            }

            Cypher.Assert(CheckGridIntegrity(creature, true));
        }

        public void GameObjectRelocation(GameObject go, float x, float y, float z, float orientation, bool respawnRelocationOnFail = true)
        {
            Cypher.Assert(CheckGridIntegrity(go, false));

            var new_cell = new Cell(x, y);

            if (!respawnRelocationOnFail &&
                GetGrid(new_cell.GetGridX(), new_cell.GetGridY()) == null)
                return;

            Cell old_cell = go.GetCurrentCell();

            // delay creature move for grid/cell to grid/cell moves
            if (old_cell.DiffCell(new_cell) ||
                old_cell.DiffGrid(new_cell))
            {
                Log.outDebug(LogFilter.Maps,
                             "GameObject (GUID: {0} Entry: {1}) added to moving list from grid[{2}, {3}]cell[{4}, {5}] to grid[{6}, {7}]cell[{8}, {9}].",
                             go.GetGUID().ToString(),
                             go.GetEntry(),
                             old_cell.GetGridX(),
                             old_cell.GetGridY(),
                             old_cell.GetCellX(),
                             old_cell.GetCellY(),
                             new_cell.GetGridX(),
                             new_cell.GetGridY(),
                             new_cell.GetCellX(),
                             new_cell.GetCellY());

                AddGameObjectToMoveList(go, x, y, z, orientation);
                // in diffcell/diffgrid case notifiers called at finishing move go in Map.MoveAllGameObjectsInMoveList
            }
            else
            {
                go.Relocate(x, y, z, orientation);
                go.AfterRelocation();
                RemoveGameObjectFromMoveList(go);
            }

            Cypher.Assert(CheckGridIntegrity(go, true));
        }

        public void DynamicObjectRelocation(DynamicObject dynObj, float x, float y, float z, float orientation)
        {
            Cypher.Assert(CheckGridIntegrity(dynObj, false));
            Cell new_cell = new(x, y);

            if (GetGrid(new_cell.GetGridX(), new_cell.GetGridY()) == null)
                return;

            Cell old_cell = dynObj.GetCurrentCell();

            // delay creature move for grid/cell to grid/cell moves
            if (old_cell.DiffCell(new_cell) ||
                old_cell.DiffGrid(new_cell))
            {
                Log.outDebug(LogFilter.Maps,
                             "DynamicObject (GUID: {0}) added to moving list from grid[{1}, {2}]cell[{3}, {4}] to grid[{5}, {6}]cell[{7}, {8}].",
                             dynObj.GetGUID().ToString(),
                             old_cell.GetGridX(),
                             old_cell.GetGridY(),
                             old_cell.GetCellX(),
                             old_cell.GetCellY(),
                             new_cell.GetGridX(),
                             new_cell.GetGridY(),
                             new_cell.GetCellX(),
                             new_cell.GetCellY());

                AddDynamicObjectToMoveList(dynObj, x, y, z, orientation);
                // in diffcell/diffgrid case notifiers called at finishing move dynObj in Map.MoveAllGameObjectsInMoveList
            }
            else
            {
                dynObj.Relocate(x, y, z, orientation);
                dynObj.UpdatePositionData();
                dynObj.UpdateObjectVisibility(false);
                RemoveDynamicObjectFromMoveList(dynObj);
            }

            Cypher.Assert(CheckGridIntegrity(dynObj, true));
        }

        public void AreaTriggerRelocation(AreaTrigger at, float x, float y, float z, float orientation)
        {
            Cypher.Assert(CheckGridIntegrity(at, false));
            Cell new_cell = new(x, y);

            if (GetGrid(new_cell.GetGridX(), new_cell.GetGridY()) == null)
                return;

            Cell old_cell = at.GetCurrentCell();

            // delay areatrigger move for grid/cell to grid/cell moves
            if (old_cell.DiffCell(new_cell) ||
                old_cell.DiffGrid(new_cell))
            {
                Log.outDebug(LogFilter.Maps, "AreaTrigger ({0}) added to moving list from {1} to {2}.", at.GetGUID().ToString(), old_cell.ToString(), new_cell.ToString());

                AddAreaTriggerToMoveList(at, x, y, z, orientation);
                // in diffcell/diffgrid case notifiers called at finishing move at in Map::MoveAllAreaTriggersInMoveList
            }
            else
            {
                at.Relocate(x, y, z, orientation);
                at.UpdateShape();
                at.UpdateObjectVisibility(false);
                RemoveAreaTriggerFromMoveList(at);
            }

            Cypher.Assert(CheckGridIntegrity(at, true));
        }

        public bool CreatureRespawnRelocation(Creature c, bool diffGridOnly)
        {
            var pos = c.GetRespawnPosition();
            var resp_cell = new Cell(pos.X, pos.Y);

            //creature will be unloaded with grid
            if (diffGridOnly && !c.GetCurrentCell().DiffGrid(resp_cell))
                return true;

            c.CombatStop();
            c.GetMotionMaster().Clear();

            // teleport it to respawn point (like normal respawn if player see)
            if (CreatureCellRelocation(c, resp_cell))
            {
                c.Relocate(pos.X, pos.Y, pos.Z, pos.Orientation);
                c.GetMotionMaster().Initialize(); // prevent possible problems with default move generators
                c.UpdatePositionData();
                c.UpdateObjectVisibility(false);

                return true;
            }

            return false;
        }

        public bool GameObjectRespawnRelocation(GameObject go, bool diffGridOnly)
        {
            float resp_x, resp_y, resp_z, resp_o;
            go.GetRespawnPosition(out resp_x, out resp_y, out resp_z, out resp_o);
            var resp_cell = new Cell(resp_x, resp_y);

            //GameObject will be unloaded with grid
            if (diffGridOnly && !go.GetCurrentCell().DiffGrid(resp_cell))
                return true;

            Log.outDebug(LogFilter.Maps,
                         "GameObject (GUID: {0} Entry: {1}) moved from grid[{2}, {3}] to respawn grid[{4}, {5}].",
                         go.GetGUID().ToString(),
                         go.GetEntry(),
                         go.GetCurrentCell().GetGridX(),
                         go.GetCurrentCell().GetGridY(),
                         resp_cell.GetGridX(),
                         resp_cell.GetGridY());

            // teleport it to respawn point (like normal respawn if player see)
            if (GameObjectCellRelocation(go, resp_cell))
            {
                go.Relocate(resp_x, resp_y, resp_z, resp_o);
                go.UpdatePositionData();
                go.UpdateObjectVisibility(false);

                return true;
            }

            return false;
        }

        public bool UnloadGrid(Grid grid, bool unloadAll)
        {
            uint x = grid.GetX();
            uint y = grid.GetY();

            if (!unloadAll)
            {
                //pets, possessed creatures (must be active), Transport passengers
                if (grid.GetWorldObjectCountInNGrid<Creature>() != 0)
                    return false;

                if (ActiveObjectsNearGrid(grid))
                    return false;
            }

            Log.outDebug(LogFilter.Maps, "Unloading grid[{0}, {1}] for map {2}", x, y, GetId());

            if (!unloadAll)
            {
                // Finish creature moves, remove and delete all creatures with delayed remove before moving to respawn grids
                // Must know real mob position before move
                MoveAllCreaturesInMoveList();
                MoveAllGameObjectsInMoveList();
                MoveAllAreaTriggersInMoveList();

                // move creatures to respawn grids if this is diff.grid or to remove list
                ObjectGridEvacuator worker = new();
                var visitor = new Visitor(worker, GridMapTypeMask.AllGrid);
                grid.VisitAllGrids(visitor);

                // Finish creature moves, remove and delete all creatures with delayed remove before unload
                MoveAllCreaturesInMoveList();
                MoveAllGameObjectsInMoveList();
                MoveAllAreaTriggersInMoveList();
            }

            {
                ObjectGridCleaner worker = new();
                var visitor = new Visitor(worker, GridMapTypeMask.AllGrid);
                grid.VisitAllGrids(visitor);
            }

            RemoveAllObjectsInRemoveList();

            // After removing all objects from the map, purge empty tracked phases
            GetMultiPersonalPhaseTracker().UnloadGrid(grid);

            {
                ObjectGridUnloader worker = new();
                var visitor = new Visitor(worker, GridMapTypeMask.AllGrid);
                grid.VisitAllGrids(visitor);
            }

            Cypher.Assert(i_objectsToRemove.Empty());
            SetGrid(null, x, y);

            int gx = (int)((MapConst.MaxGrids - 1) - x);
            int gy = (int)((MapConst.MaxGrids - 1) - y);

            _terrain.UnloadMap(gx, gy);

            Log.outDebug(LogFilter.Maps, "Unloading grid[{0}, {1}] for map {2} finished", x, y, GetId());

            return true;
        }

        public virtual void RemoveAllPlayers()
        {
            if (HavePlayers())
                foreach (Player pl in _activePlayers)
                    if (!pl.IsBeingTeleportedFar())
                    {
                        // this is happening for bg
                        Log.outError(LogFilter.Maps, $"Map.UnloadAll: player {pl.GetName()} is still in map {GetId()} during unload, this should not happen!");
                        pl.TeleportTo(pl.GetHomebind());
                    }
        }

        public void UnloadAll()
        {
            // clear all delayed moves, useless anyway do this moves before map unload.
            creaturesToMove.Clear();
            _gameObjectsToMove.Clear();

            for (uint x = 0; x < MapConst.MaxGrids; ++x)
            {
                for (uint y = 0; y < MapConst.MaxGrids; ++y)
                {
                    var grid = GetGrid(x, y);

                    if (grid == null)
                        continue;

                    UnloadGrid(grid, true); // deletes the grid and removes it from the GridRefManager
                }
            }

            for (var i = 0; i < _transports.Count; ++i)
                RemoveFromMap(_transports[i], true);

            _transports.Clear();

            foreach (var corpse in _corpsesByCell.Values.ToList())
            {
                corpse.RemoveFromWorld();
                corpse.ResetMap();
                corpse.Dispose();
            }

            _corpsesByCell.Clear();
            _corpsesByPlayer.Clear();
            _corpseBones.Clear();
        }

        public static bool IsInWMOInterior(uint mogpFlags)
        {
            return (mogpFlags & 0x2000) != 0;
        }

        public void GetFullTerrainStatusForPosition(PhaseShift phaseShift, float x, float y, float z, PositionFullTerrainStatus data, LiquidHeaderTypeFlags reqLiquidType, float collisionHeight = MapConst.DefaultCollesionHeight)
        {
            _terrain.GetFullTerrainStatusForPosition(phaseShift, GetId(), x, y, z, data, reqLiquidType, collisionHeight, _dynamicTree);
        }

        public ZLiquidStatus GetLiquidStatus(PhaseShift phaseShift, float x, float y, float z, LiquidHeaderTypeFlags reqLiquidType, float collisionHeight = MapConst.DefaultCollesionHeight)
        {
            return _terrain.GetLiquidStatus(phaseShift, GetId(), x, y, z, reqLiquidType, null, collisionHeight);
        }

        public ZLiquidStatus GetLiquidStatus(PhaseShift phaseShift, float x, float y, float z, LiquidHeaderTypeFlags reqLiquidType, LiquidData data, float collisionHeight = MapConst.DefaultCollesionHeight)
        {
            return _terrain.GetLiquidStatus(phaseShift, GetId(), x, y, z, reqLiquidType, data, collisionHeight);
        }

        public uint GetAreaId(PhaseShift phaseShift, Position pos)
        {
            return _terrain.GetAreaId(phaseShift, GetId(), pos.X, pos.Y, pos.Z, _dynamicTree);
        }

        public uint GetAreaId(PhaseShift phaseShift, float x, float y, float z)
        {
            return _terrain.GetAreaId(phaseShift, GetId(), x, y, z, _dynamicTree);
        }

        public uint GetZoneId(PhaseShift phaseShift, Position pos)
        {
            return _terrain.GetZoneId(phaseShift, GetId(), pos.X, pos.Y, pos.Z, _dynamicTree);
        }

        public uint GetZoneId(PhaseShift phaseShift, float x, float y, float z)
        {
            return _terrain.GetZoneId(phaseShift, GetId(), x, y, z, _dynamicTree);
        }

        public void GetZoneAndAreaId(PhaseShift phaseShift, out uint zoneid, out uint areaid, Position pos)
        {
            _terrain.GetZoneAndAreaId(phaseShift, GetId(), out zoneid, out areaid, pos.X, pos.Y, pos.Z, _dynamicTree);
        }

        public void GetZoneAndAreaId(PhaseShift phaseShift, out uint zoneid, out uint areaid, float x, float y, float z)
        {
            _terrain.GetZoneAndAreaId(phaseShift, GetId(), out zoneid, out areaid, x, y, z, _dynamicTree);
        }

        public float GetHeight(PhaseShift phaseShift, float x, float y, float z, bool vmap = true, float maxSearchDist = MapConst.DefaultHeightSearch)
        {
            return Math.Max(GetStaticHeight(phaseShift, x, y, z, vmap, maxSearchDist), GetGameObjectFloor(phaseShift, x, y, z, maxSearchDist));
        }

        public float GetHeight(PhaseShift phaseShift, Position pos, bool vmap = true, float maxSearchDist = MapConst.DefaultHeightSearch)
        {
            return GetHeight(phaseShift, pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), vmap, maxSearchDist);
        }

        public float GetMinHeight(PhaseShift phaseShift, float x, float y)
        {
            return _terrain.GetMinHeight(phaseShift, GetId(), x, y);
        }

        public float GetGridHeight(PhaseShift phaseShift, float x, float y)
        {
            return _terrain.GetGridHeight(phaseShift, GetId(), x, y);
        }

        public float GetStaticHeight(PhaseShift phaseShift, float x, float y, float z, bool checkVMap = true, float maxSearchDist = MapConst.DefaultHeightSearch)
        {
            return _terrain.GetStaticHeight(phaseShift, GetId(), x, y, z, checkVMap, maxSearchDist);
        }

        public float GetWaterLevel(PhaseShift phaseShift, float x, float y)
        {
            return _terrain.GetWaterLevel(phaseShift, GetId(), x, y);
        }

        public bool IsInWater(PhaseShift phaseShift, float x, float y, float z, LiquidData data)
        {
            return _terrain.IsInWater(phaseShift, GetId(), x, y, z, data);
        }

        public bool IsUnderWater(PhaseShift phaseShift, float x, float y, float z)
        {
            return _terrain.IsUnderWater(phaseShift, GetId(), x, y, z);
        }

        public float GetWaterOrGroundLevel(PhaseShift phaseShift, float x, float y, float z, float collisionHeight = MapConst.DefaultCollesionHeight)
        {
            float ground = 0;

            return _terrain.GetWaterOrGroundLevel(phaseShift, GetId(), x, y, z, ref ground, false, collisionHeight, _dynamicTree);
        }

        public float GetWaterOrGroundLevel(PhaseShift phaseShift, float x, float y, float z, ref float ground, bool swim = false, float collisionHeight = MapConst.DefaultCollesionHeight)
        {
            return _terrain.GetWaterOrGroundLevel(phaseShift, GetId(), x, y, z, ref ground, swim, collisionHeight, _dynamicTree);
        }

        public bool IsInLineOfSight(PhaseShift phaseShift, float x1, float y1, float z1, float x2, float y2, float z2, LineOfSightChecks checks, ModelIgnoreFlags ignoreFlags)
        {
            if (checks.HasAnyFlag(LineOfSightChecks.Vmap) &&
                !Global.VMapMgr.IsInLineOfSight(PhasingHandler.GetTerrainMapId(phaseShift, GetId(), _terrain, x1, y1), x1, y1, z1, x2, y2, z2, ignoreFlags))
                return false;

            if (WorldConfig.GetBoolValue(WorldCfg.CheckGobjectLos) &&
                checks.HasAnyFlag(LineOfSightChecks.Gobject) &&
                !_dynamicTree.IsInLineOfSight(new Vector3(x1, y1, z1), new Vector3(x2, y2, z2), phaseShift))
                return false;

            return true;
        }

        public bool GetObjectHitPos(PhaseShift phaseShift, float x1, float y1, float z1, float x2, float y2, float z2, out float rx, out float ry, out float rz, float modifyDist)
        {
            var startPos = new Vector3(x1, y1, z1);
            var dstPos = new Vector3(x2, y2, z2);

            var resultPos = new Vector3();
            bool result = _dynamicTree.GetObjectHitPos(startPos, dstPos, ref resultPos, modifyDist, phaseShift);

            rx = resultPos.X;
            ry = resultPos.Y;
            rz = resultPos.Z;

            return result;
        }

        public static TransferAbortParams PlayerCannotEnter(uint mapid, Player player)
        {
            var entry = CliDB.MapStorage.LookupByKey(mapid);

            if (entry == null)
                return new TransferAbortParams(TransferAbortReason.MapNotAllowed);

            if (!entry.IsDungeon())
                return null;

            Difficulty targetDifficulty = player.GetDifficultyID(entry);
            // Get the highest available difficulty if current setting is higher than the instance allows
            var mapDiff = Global.DB2Mgr.GetDownscaledMapDifficultyData(mapid, ref targetDifficulty);

            if (mapDiff == null)
                return new TransferAbortParams(TransferAbortReason.Difficulty);

            //Bypass checks for GMs
            if (player.IsGameMaster())
                return null;

            //Other requirements
            {
                TransferAbortParams abortParams = new();

                if (!player.Satisfy(Global.ObjectMgr.GetAccessRequirement(mapid, targetDifficulty), mapid, abortParams, true))
                    return abortParams;
            }

            Group group = player.GetGroup();

            if (entry.IsRaid() &&
                (int)entry.Expansion() >= WorldConfig.GetIntValue(WorldCfg.Expansion)) // can only enter in a raid group but raids from old expansion don't need a group
                if ((!group || !group.IsRaidGroup()) &&
                    !WorldConfig.GetBoolValue(WorldCfg.InstanceIgnoreRaid))
                    return new TransferAbortParams(TransferAbortReason.NeedGroup);

            if (entry.Instanceable())
            {
                //Get instance where player's group is bound & its map
                uint instanceIdToCheck = Global.MapMgr.FindInstanceIdForPlayer(mapid, player);
                Map boundMap = Global.MapMgr.FindMap(mapid, instanceIdToCheck);

                if (boundMap != null)
                {
                    TransferAbortParams denyReason = boundMap.CannotEnter(player);

                    if (denyReason != null)
                        return denyReason;
                }

                // players are only allowed to enter 10 instances per hour
                if (!entry.GetFlags2().HasFlag(MapFlags2.IgnoreInstanceFarmLimit) &&
                    entry.IsDungeon() &&
                    !player.CheckInstanceCount(instanceIdToCheck) &&
                    !player.IsDead())
                    return new TransferAbortParams(TransferAbortReason.TooManyInstances);
            }

            return null;
        }

        public string GetMapName()
        {
            return i_mapRecord.MapName[Global.WorldMgr.GetDefaultDbcLocale()];
        }

        public void SendInitSelf(Player player)
        {
            var data = new UpdateData(player.GetMapId());

            // attach to player _data current Transport _data
            Transport transport = player.GetTransport<Transport>();

            if (transport != null)
            {
                transport.BuildCreateUpdateBlockForPlayer(data, player);
                player.VisibleTransports.Add(transport.GetGUID());
            }

            player.BuildCreateUpdateBlockForPlayer(data, player);

            // build other passengers at Transport also (they always visible and marked as visible and will not send at visibility update at add to map
            if (transport != null)
                foreach (WorldObject passenger in transport.GetPassengers())
                    if (player != passenger &&
                        player.HaveAtClient(passenger))
                        passenger.BuildCreateUpdateBlockForPlayer(data, player);

            UpdateObject packet;
            data.BuildPacket(out packet);
            player.SendPacket(packet);
        }

        public void SendUpdateTransportVisibility(Player player)
        {
            // Hack to send out transports
            UpdateData transData = new(player.GetMapId());

            foreach (var transport in _transports)
            {
                if (!transport.IsInWorld)
                    continue;

                var hasTransport = player.VisibleTransports.Contains(transport.GetGUID());

                if (player.InSamePhase(transport))
                {
                    if (!hasTransport)
                    {
                        transport.BuildCreateUpdateBlockForPlayer(transData, player);
                        player.VisibleTransports.Add(transport.GetGUID());
                    }
                }
                else
                {
                    transport.BuildOutOfRangeUpdateBlock(transData);
                    player.VisibleTransports.Remove(transport.GetGUID());
                }
            }

            UpdateObject packet;
            transData.BuildPacket(out packet);
            player.SendPacket(packet);
        }

        public void Respawn(SpawnObjectType type, ulong spawnId, SQLTransaction dbTrans = null)
        {
            RespawnInfo info = GetRespawnInfo(type, spawnId);

            if (info != null)
                Respawn(info, dbTrans);
        }

        public void Respawn(RespawnInfo info, SQLTransaction dbTrans = null)
        {
            if (info.RespawnTime <= GameTime.GetGameTime())
                return;

            info.RespawnTime = GameTime.GetGameTime();
            SaveRespawnInfoDB(info, dbTrans);
        }

        public void RemoveRespawnTime(SpawnObjectType type, ulong spawnId, SQLTransaction dbTrans = null, bool alwaysDeleteFromDB = false)
        {
            RespawnInfo info = GetRespawnInfo(type, spawnId);

            if (info != null)
                DeleteRespawnInfo(info, dbTrans);
            // Some callers might need to make sure the database doesn't contain any respawn Time
            else if (alwaysDeleteFromDB)
                DeleteRespawnInfoFromDB(type, spawnId, dbTrans);
        }

        public void GetRespawnInfo(List<RespawnInfo> respawnData, SpawnObjectTypeMask types)
        {
            if ((types & SpawnObjectTypeMask.Creature) != 0)
                PushRespawnInfoFrom(respawnData, _creatureRespawnTimesBySpawnId);

            if ((types & SpawnObjectTypeMask.GameObject) != 0)
                PushRespawnInfoFrom(respawnData, _gameObjectRespawnTimesBySpawnId);
        }

        public RespawnInfo GetRespawnInfo(SpawnObjectType type, ulong spawnId)
        {
            var map = GetRespawnMapForType(type);

            if (map == null)
                return null;

            var respawnInfo = map.LookupByKey(spawnId);

            if (respawnInfo == null)
                return null;

            return respawnInfo;
        }

        public void ApplyDynamicModeRespawnScaling(WorldObject obj, ulong spawnId, ref uint respawnDelay, uint mode)
        {
            Cypher.Assert(mode == 1);
            Cypher.Assert(obj.GetMap() == this);

            if (IsBattlegroundOrArena())
                return;

            SpawnObjectType type;

            switch (obj.GetTypeId())
            {
                case TypeId.Unit:
                    type = SpawnObjectType.Creature;

                    break;
                case TypeId.GameObject:
                    type = SpawnObjectType.GameObject;

                    break;
                default:
                    return;
            }

            SpawnMetadata data = Global.ObjectMgr.GetSpawnMetadata(type, spawnId);

            if (data == null)
                return;

            if (!data.spawnGroupData.flags.HasFlag(SpawnGroupFlags.DynamicSpawnRate))
                return;

            if (!_zonePlayerCountMap.ContainsKey(obj.GetZoneId()))
                return;

            uint playerCount = _zonePlayerCountMap[obj.GetZoneId()];

            if (playerCount == 0)
                return;

            double adjustFactor = WorldConfig.GetFloatValue(type == SpawnObjectType.GameObject ? WorldCfg.RespawnDynamicRateGameobject : WorldCfg.RespawnDynamicRateCreature) / playerCount;

            if (adjustFactor >= 1.0) // nothing to do here
                return;

            uint timeMinimum = WorldConfig.GetUIntValue(type == SpawnObjectType.GameObject ? WorldCfg.RespawnDynamicMinimumGameObject : WorldCfg.RespawnDynamicMinimumCreature);

            if (respawnDelay <= timeMinimum)
                return;

            respawnDelay = (uint)Math.Max(Math.Ceiling(respawnDelay * adjustFactor), timeMinimum);
        }

        public bool ShouldBeSpawnedOnGridLoad<T>(ulong spawnId)
        {
            return ShouldBeSpawnedOnGridLoad(SpawnData.TypeFor<T>(), spawnId);
        }

        public bool SpawnGroupSpawn(uint groupId, bool ignoreRespawn = false, bool force = false, List<WorldObject> spawnedObjects = null)
        {
            var groupData = GetSpawnGroupData(groupId);

            if (groupData == null ||
                groupData.flags.HasAnyFlag(SpawnGroupFlags.System))
            {
                Log.outError(LogFilter.Maps, $"Tried to spawn non-existing (or system) spawn group {groupId}. on map {GetId()} Blocked.");

                return false;
            }

            SetSpawnGroupActive(groupId, true); // start processing respawns for the group

            List<SpawnData> toSpawn = new();

            foreach (var data in Global.ObjectMgr.GetSpawnMetadataForGroup(groupId))
            {
                Cypher.Assert(groupData.mapId == data.MapId);

                var respawnMap = GetRespawnMapForType(data.type);

                if (respawnMap == null)
                    continue;

                if (force || ignoreRespawn)
                    RemoveRespawnTime(data.type, data.SpawnId);

                bool hasRespawnTimer = respawnMap.ContainsKey(data.SpawnId);

                if (SpawnMetadata.TypeHasData(data.type))
                {
                    // has a respawn timer
                    if (hasRespawnTimer)
                        continue;

                    // has a spawn already active
                    if (!force)
                    {
                        WorldObject obj = GetWorldObjectBySpawnId(data.type, data.SpawnId);

                        if (obj != null)
                            if ((data.type != SpawnObjectType.Creature) ||
                                obj.ToCreature().IsAlive())
                                continue;
                    }

                    toSpawn.Add(data.ToSpawnData());
                }
            }

            foreach (SpawnData data in toSpawn)
            {
                // don't spawn if the current map difficulty is not used by the spawn
                if (!data.SpawnDifficulties.Contains(GetDifficultyID()))
                    continue;

                // don't spawn if the grid isn't loaded (will be handled in grid loader)
                if (!IsGridLoaded(data.SpawnPoint))
                    continue;

                // now do the actual (re)spawn
                switch (data.type)
                {
                    case SpawnObjectType.Creature:
                        {
                            Creature creature = new();

                            if (!creature.LoadFromDB(data.SpawnId, this, true, force))
                                creature.Dispose();
                            else spawnedObjects?.Add(creature);

                            break;
                        }
                    case SpawnObjectType.GameObject:
                        {
                            GameObject gameobject = new();

                            if (!gameobject.LoadFromDB(data.SpawnId, this, true))
                                gameobject.Dispose();
                            else spawnedObjects?.Add(gameobject);

                            break;
                        }
                    case SpawnObjectType.AreaTrigger:
                        {
                            AreaTrigger areaTrigger = new();

                            if (!areaTrigger.LoadFromDB(data.SpawnId, this, true, false))
                                areaTrigger.Dispose();
                            else spawnedObjects?.Add(areaTrigger);

                            break;
                        }
                    default:
                        Cypher.Assert(false, $"Invalid spawn Type {data.type} with spawnId {data.SpawnId}");

                        return false;
                }
            }

            return true;
        }

        public bool SpawnGroupDespawn(uint groupId, bool deleteRespawnTimes = false)
        {
            return SpawnGroupDespawn(groupId, deleteRespawnTimes, out _);
        }

        public bool SpawnGroupDespawn(uint groupId, bool deleteRespawnTimes, out int count)
        {
            count = 0;
            SpawnGroupTemplateData groupData = GetSpawnGroupData(groupId);

            if (groupData == null ||
                groupData.flags.HasAnyFlag(SpawnGroupFlags.System))
            {
                Log.outError(LogFilter.Maps, $"Tried to despawn non-existing (or system) spawn group {groupId} on map {GetId()}. Blocked.");

                return false;
            }

            foreach (var data in Global.ObjectMgr.GetSpawnMetadataForGroup(groupId))
            {
                Cypher.Assert(groupData.mapId == data.MapId);

                if (deleteRespawnTimes)
                    RemoveRespawnTime(data.type, data.SpawnId);

                count += DespawnAll(data.type, data.SpawnId);
            }

            SetSpawnGroupActive(groupId, false); // stop processing respawns for the group, too

            return true;
        }

        public void SetSpawnGroupActive(uint groupId, bool state)
        {
            SpawnGroupTemplateData data = GetSpawnGroupData(groupId);

            if (data == null ||
                data.flags.HasAnyFlag(SpawnGroupFlags.System))
            {
                Log.outError(LogFilter.Maps, $"Tried to set non-existing (or system) spawn group {groupId} to {(state ? "active" : "inactive")} on map {GetId()}. Blocked.");

                return;
            }

            if (state != !data.flags.HasAnyFlag(SpawnGroupFlags.ManualSpawn)) // toggled
                _toggledSpawnGroupIds.Add(groupId);
            else
                _toggledSpawnGroupIds.Remove(groupId);
        }

        // Disable the spawn group, which prevents any creatures in the group from respawning until re-enabled
        // This will not affect any already-present creatures in the group
        public void SetSpawnGroupInactive(uint groupId)
        {
            SetSpawnGroupActive(groupId, false);
        }

        public bool IsSpawnGroupActive(uint groupId)
        {
            SpawnGroupTemplateData data = GetSpawnGroupData(groupId);

            if (data == null)
            {
                Log.outError(LogFilter.Maps, $"Tried to query State of non-existing spawn group {groupId} on map {GetId()}.");

                return false;
            }

            if (data.flags.HasAnyFlag(SpawnGroupFlags.System))
                return true;

            // either manual spawn group and toggled, or not manual spawn group and not toggled...
            return _toggledSpawnGroupIds.Contains(groupId) != !data.flags.HasAnyFlag(SpawnGroupFlags.ManualSpawn);
        }

        public void UpdateSpawnGroupConditions()
        {
            var spawnGroups = Global.ObjectMgr.GetSpawnGroupsForMap(GetId());

            foreach (uint spawnGroupId in spawnGroups)
            {
                SpawnGroupTemplateData spawnGroupTemplate = GetSpawnGroupData(spawnGroupId);

                if (spawnGroupTemplate.flags.HasFlag(SpawnGroupFlags.ManualSpawn))
                    continue;

                bool isActive = IsSpawnGroupActive(spawnGroupId);
                bool shouldBeActive = Global.ConditionMgr.IsMapMeetingNotGroupedConditions(ConditionSourceType.SpawnGroup, spawnGroupId, this);

                if (isActive == shouldBeActive)
                    continue;

                if (shouldBeActive)
                    SpawnGroupSpawn(spawnGroupId);
                else if (spawnGroupTemplate.flags.HasFlag(SpawnGroupFlags.DespawnOnConditionFailure))
                    SpawnGroupDespawn(spawnGroupId, true);
                else
                    SetSpawnGroupInactive(spawnGroupId);
            }
        }

        public void AddFarSpellCallback(FarSpellCallback callback)
        {
            _farSpellCallbacks.Enqueue(new FarSpellCallback(callback));
        }

        public virtual void DelayedUpdate(uint diff)
        {
            while (_farSpellCallbacks.TryDequeue(out FarSpellCallback callback))
                callback(this);

            RemoveAllObjectsInRemoveList();

            // Don't unload grids if it's Battleground, since we may have manually added GOs, creatures, those doesn't load from DB at grid re-load !
            // This isn't really bother us, since as soon as we have instanced BG-s, the whole map unloads as the BG gets ended
            if (!IsBattlegroundOrArena())
                for (uint x = 0; x < MapConst.MaxGrids; ++x)
                {
                    for (uint y = 0; y < MapConst.MaxGrids; ++y)
                    {
                        Grid grid = GetGrid(x, y);

                        grid?.Update(this, diff);
                    }
                }
        }

        public void AddObjectToRemoveList(WorldObject obj)
        {
            Cypher.Assert(obj.GetMapId() == GetId() && obj.GetInstanceId() == GetInstanceId());

            obj.SetDestroyedObject(true);
            obj.CleanupsBeforeDelete(false); // remove or simplify at least cross referenced links

            i_objectsToRemove.Add(obj);
        }

        public void AddObjectToSwitchList(WorldObject obj, bool on)
        {
            Cypher.Assert(obj.GetMapId() == GetId() && obj.GetInstanceId() == GetInstanceId());

            // i_objectsToSwitch is iterated only in Map::RemoveAllObjectsInRemoveList() and it uses
            // the contained objects only if GetTypeId() == TYPEID_UNIT , so we can return in all other cases
            if (!obj.IsTypeId(TypeId.Unit))
                return;

            if (!i_objectsToSwitch.ContainsKey(obj))
                i_objectsToSwitch.Add(obj, on);
            else if (i_objectsToSwitch[obj] != on)
                i_objectsToSwitch.Remove(obj);
            else
                Cypher.Assert(false);
        }

        public uint GetPlayersCountExceptGMs()
        {
            uint count = 0;

            foreach (Player pl in _activePlayers)
                if (!pl.IsGameMaster())
                    ++count;

            return count;
        }

        public void SendToPlayers(ServerPacket data)
        {
            foreach (Player pl in _activePlayers)
                pl.SendPacket(data);
        }

        public bool ActiveObjectsNearGrid(Grid grid)
        {
            var cell_min = new CellCoord(grid.GetX() * MapConst.MaxCells,
                                         grid.GetY() * MapConst.MaxCells);

            var cell_max = new CellCoord(cell_min.X_coord + MapConst.MaxCells,
                                         cell_min.Y_coord + MapConst.MaxCells);

            //we must find visible range in cells so we unload only non-visible cells...
            float viewDist = GetVisibilityRange();
            uint cell_range = (uint)Math.Ceiling(viewDist / MapConst.SizeofCells) + 1;

            cell_min.Dec_x(cell_range);
            cell_min.Dec_y(cell_range);
            cell_max.Inc_x(cell_range);
            cell_max.Inc_y(cell_range);

            foreach (Player pl in _activePlayers)
            {
                CellCoord p = GridDefines.ComputeCellCoord(pl.GetPositionX(), pl.GetPositionY());

                if ((cell_min.X_coord <= p.X_coord && p.X_coord <= cell_max.X_coord) &&
                    (cell_min.Y_coord <= p.Y_coord && p.Y_coord <= cell_max.Y_coord))
                    return true;
            }

            foreach (WorldObject obj in _activeNonPlayers)
            {
                CellCoord p = GridDefines.ComputeCellCoord(obj.GetPositionX(), obj.GetPositionY());

                if ((cell_min.X_coord <= p.X_coord && p.X_coord <= cell_max.X_coord) &&
                    (cell_min.Y_coord <= p.Y_coord && p.Y_coord <= cell_max.Y_coord))
                    return true;
            }

            return false;
        }

        public void AddToActive(WorldObject obj)
        {
            AddToActiveHelper(obj);

            Position respawnLocation = null;

            switch (obj.GetTypeId())
            {
                case TypeId.Unit:
                    Creature creature = obj.ToCreature();

                    if (creature != null &&
                        !creature.IsPet() &&
                        creature.GetSpawnId() != 0)
                    {
                        respawnLocation = creature.GetRespawnPosition();
                    }

                    break;
                case TypeId.GameObject:
                    GameObject gameObject = obj.ToGameObject();
                    ;

                    if (gameObject != null &&
                        gameObject.GetSpawnId() != 0)
                    {
                        respawnLocation = new Position();
                        gameObject.GetRespawnPosition(out respawnLocation.X, out respawnLocation.Y, out respawnLocation.Z, out _);
                    }

                    break;
                default:
                    break;
            }

            if (respawnLocation != null)
            {
                GridCoord p = GridDefines.ComputeGridCoord(respawnLocation.GetPositionX(), respawnLocation.GetPositionY());

                if (GetGrid(p.X_coord, p.Y_coord) != null)
                {
                    GetGrid(p.X_coord, p.Y_coord).IncUnloadActiveLock();
                }
                else
                {
                    GridCoord p2 = GridDefines.ComputeGridCoord(obj.GetPositionX(), obj.GetPositionY());
                    Log.outError(LogFilter.Maps, $"Active object {obj.GetGUID()} added to grid[{p.X_coord}, {p.Y_coord}] but spawn grid[{p2.X_coord}, {p2.Y_coord}] was not loaded.");
                }
            }
        }

        public void RemoveFromActive(WorldObject obj)
        {
            RemoveFromActiveHelper(obj);

            Position respawnLocation = null;

            switch (obj.GetTypeId())
            {
                case TypeId.Unit:
                    Creature creature = obj.ToCreature();

                    if (creature != null &&
                        !creature.IsPet() &&
                        creature.GetSpawnId() != 0)
                    {
                        respawnLocation = creature.GetRespawnPosition();
                    }

                    break;
                case TypeId.GameObject:
                    GameObject gameObject = obj.ToGameObject();

                    if (gameObject != null &&
                        gameObject.GetSpawnId() != 0)
                    {
                        respawnLocation = new Position();
                        gameObject.GetRespawnPosition(out respawnLocation.X, out respawnLocation.Y, out respawnLocation.Z, out _);
                    }

                    break;
                default:
                    break;
            }

            if (respawnLocation != null)
            {
                GridCoord p = GridDefines.ComputeGridCoord(respawnLocation.GetPositionX(), respawnLocation.GetPositionY());

                if (GetGrid(p.X_coord, p.Y_coord) != null)
                {
                    GetGrid(p.X_coord, p.Y_coord).DecUnloadActiveLock();
                }
                else
                {
                    GridCoord p2 = GridDefines.ComputeGridCoord(obj.GetPositionX(), obj.GetPositionY());
                    Log.outDebug(LogFilter.Maps, $"Active object {obj.GetGUID()} removed from grid[{p.X_coord}, {p.Y_coord}] but spawn grid[{p2.X_coord}, {p2.Y_coord}] was not loaded.");
                }
            }
        }

        public void SaveRespawnTime(SpawnObjectType type, ulong spawnId, uint entry, long respawnTime, uint gridId = 0, SQLTransaction dbTrans = null, bool startup = false)
        {
            SpawnMetadata data = Global.ObjectMgr.GetSpawnMetadata(type, spawnId);

            if (data == null)
            {
                Log.outError(LogFilter.Maps, $"Map {GetId()} attempt to save respawn Time for nonexistant spawnid ({type},{spawnId}).");

                return;
            }

            if (respawnTime == 0)
            {
                // Delete only
                RemoveRespawnTime(data.type, data.SpawnId, dbTrans);

                return;
            }

            RespawnInfo ri = new();
            ri.Type = data.type;
            ri.SpawnId = data.SpawnId;
            ri.Entry = entry;
            ri.RespawnTime = respawnTime;
            ri.GridId = gridId;
            bool success = AddRespawnInfo(ri);

            if (startup)
            {
                if (!success)
                    Log.outError(LogFilter.Maps, $"Attempt to load saved respawn {respawnTime} for ({type},{spawnId}) failed - duplicate respawn? Skipped.");
            }
            else if (success)
            {
                SaveRespawnInfoDB(ri, dbTrans);
            }
        }

        public void SaveRespawnInfoDB(RespawnInfo info, SQLTransaction dbTrans = null)
        {
            if (Instanceable())
                return;

            PreparedStatement stmt = DB.Characters.GetPreparedStatement(CharStatements.REP_RESPAWN);
            stmt.AddValue(0, (ushort)info.Type);
            stmt.AddValue(1, info.SpawnId);
            stmt.AddValue(2, info.RespawnTime);
            stmt.AddValue(3, GetId());
            stmt.AddValue(4, GetInstanceId());
            DB.Characters.ExecuteOrAppend(dbTrans, stmt);
        }

        public void LoadRespawnTimes()
        {
            if (Instanceable())
                return;

            PreparedStatement stmt = DB.Characters.GetPreparedStatement(CharStatements.SEL_RESPAWNS);
            stmt.AddValue(0, GetId());
            stmt.AddValue(1, GetInstanceId());
            SQLResult result = DB.Characters.Query(stmt);

            if (!result.IsEmpty())
                do
                {
                    SpawnObjectType type = (SpawnObjectType)result.Read<ushort>(0);
                    var spawnId = result.Read<ulong>(1);
                    var respawnTime = result.Read<long>(2);

                    if (SpawnMetadata.TypeHasData(type))
                    {
                        SpawnData data = Global.ObjectMgr.GetSpawnData(type, spawnId);

                        if (data != null)
                            SaveRespawnTime(type, spawnId, data.Id, respawnTime, GridDefines.ComputeGridCoord(data.SpawnPoint.GetPositionX(), data.SpawnPoint.GetPositionY()).GetId(), null, true);
                        else
                            Log.outError(LogFilter.Maps, $"Loading saved respawn Time of {respawnTime} for spawnid ({type},{spawnId}) - spawn does not exist, ignoring");
                    }
                    else
                    {
                        Log.outError(LogFilter.Maps, $"Loading saved respawn Time of {respawnTime} for spawnid ({type},{spawnId}) - invalid spawn Type, ignoring");
                    }
                } while (result.NextRow());
        }

        public void DeleteRespawnTimes()
        {
            UnloadAllRespawnInfos();
            DeleteRespawnTimesInDB();
        }

        public void DeleteRespawnTimesInDB()
        {
            if (Instanceable())
                return;

            PreparedStatement stmt = DB.Characters.GetPreparedStatement(CharStatements.DEL_ALL_RESPAWNS);
            stmt.AddValue(0, GetId());
            stmt.AddValue(1, GetInstanceId());
            DB.Characters.Execute(stmt);
        }

        public long GetLinkedRespawnTime(ObjectGuid guid)
        {
            ObjectGuid linkedGuid = Global.ObjectMgr.GetLinkedRespawnGuid(guid);

            switch (linkedGuid.GetHigh())
            {
                case HighGuid.Creature:
                    return GetCreatureRespawnTime(linkedGuid.GetCounter());
                case HighGuid.GameObject:
                    return GetGORespawnTime(linkedGuid.GetCounter());
                default:
                    break;
            }

            return 0L;
        }

        public void LoadCorpseData()
        {
            PreparedStatement stmt = DB.Characters.GetPreparedStatement(CharStatements.SEL_CORPSES);
            stmt.AddValue(0, GetId());
            stmt.AddValue(1, GetInstanceId());

            //        0     1     2     3            4      5          6          7     8      9       10     11        12    13          14          15
            // SELECT X, Y, Z, orientation, mapId, displayId, itemCache, race, class, Gender, Flags, dynFlags, Time, corpseType, InstanceId, Guid FROM corpse WHERE mapId = ? AND InstanceId = ?
            SQLResult result = DB.Characters.Query(stmt);

            if (result.IsEmpty())
                return;

            MultiMap<ulong, uint> phases = new();
            MultiMap<ulong, ChrCustomizationChoice> customizations = new();

            stmt = DB.Characters.GetPreparedStatement(CharStatements.SEL_CORPSE_PHASES);
            stmt.AddValue(0, GetId());
            stmt.AddValue(1, GetInstanceId());

            //        0          1
            // SELECT OwnerGuid, PhaseId FROM corpse_phases cp LEFT JOIN corpse c ON cp.OwnerGuid = c.Guid WHERE c.mapId = ? AND c.InstanceId = ?
            SQLResult phaseResult = DB.Characters.Query(stmt);

            if (!phaseResult.IsEmpty())
                do
                {
                    ulong guid = phaseResult.Read<ulong>(0);
                    uint phaseId = phaseResult.Read<uint>(1);

                    phases.Add(guid, phaseId);
                } while (phaseResult.NextRow());

            stmt = DB.Characters.GetPreparedStatement(CharStatements.SEL_CORPSE_CUSTOMIZATIONS);
            stmt.AddValue(0, GetId());
            stmt.AddValue(1, GetInstanceId());

            //        0             1                            2
            // SELECT cc.ownerGuid, cc.chrCustomizationOptionID, cc.chrCustomizationChoiceID FROM corpse_customizations cc LEFT JOIN corpse c ON cc.ownerGuid = c.Guid WHERE c.mapId = ? AND c.InstanceId = ?
            SQLResult customizationResult = DB.Characters.Query(stmt);

            if (!customizationResult.IsEmpty())
                do
                {
                    ulong guid = customizationResult.Read<ulong>(0);

                    ChrCustomizationChoice choice = new();
                    choice.ChrCustomizationOptionID = customizationResult.Read<uint>(1);
                    choice.ChrCustomizationChoiceID = customizationResult.Read<uint>(2);
                    customizations.Add(guid, choice);
                } while (customizationResult.NextRow());

            do
            {
                CorpseType type = (CorpseType)result.Read<byte>(13);
                ulong guid = result.Read<ulong>(15);

                if (type >= CorpseType.Max ||
                    type == CorpseType.Bones)
                {
                    Log.outError(LogFilter.Maps, "Corpse (Guid: {0}) have wrong corpse Type ({1}), not loading.", guid, type);

                    continue;
                }

                Corpse corpse = new(type);

                if (!corpse.LoadCorpseFromDB(GenerateLowGuid(HighGuid.Corpse), result.GetFields()))
                    continue;

                foreach (var phaseId in phases[guid])
                    PhasingHandler.AddPhase(corpse, phaseId, false);

                corpse.SetCustomizations(customizations[guid]);

                AddCorpse(corpse);
            } while (result.NextRow());
        }

        public void DeleteCorpseData()
        {
            // DELETE cp, c FROM corpse_phases cp INNER JOIN corpse c ON cp.OwnerGuid = c.Guid WHERE c.mapId = ? AND c.InstanceId = ?
            PreparedStatement stmt = DB.Characters.GetPreparedStatement(CharStatements.DEL_CORPSES_FROM_MAP);
            stmt.AddValue(0, GetId());
            stmt.AddValue(1, GetInstanceId());
            DB.Characters.Execute(stmt);
        }

        public void AddCorpse(Corpse corpse)
        {
            corpse.SetMap(this);

            _corpsesByCell.Add(corpse.GetCellCoord().GetId(), corpse);

            if (corpse.GetCorpseType() != CorpseType.Bones)
                _corpsesByPlayer[corpse.GetOwnerGUID()] = corpse;
            else
                _corpseBones.Add(corpse);
        }

        public Corpse ConvertCorpseToBones(ObjectGuid ownerGuid, bool insignia = false)
        {
            Corpse corpse = GetCorpseByPlayer(ownerGuid);

            if (!corpse)
                return null;

            RemoveCorpse(corpse);

            // remove corpse from DB
            SQLTransaction trans = new();
            corpse.DeleteFromDB(trans);
            DB.Characters.CommitTransaction(trans);

            Corpse bones = null;

            // create the bones only if the map and the grid is loaded at the corpse's location
            // ignore bones creating option in case insignia
            if ((insignia ||
                 (IsBattlegroundOrArena() ? WorldConfig.GetBoolValue(WorldCfg.DeathBonesBgOrArena) : WorldConfig.GetBoolValue(WorldCfg.DeathBonesWorld))) &&
                !IsRemovalGrid(corpse.GetPositionX(), corpse.GetPositionY()))
            {
                // Create bones, don't change Corpse
                bones = new Corpse();
                bones.Create(corpse.GetGUID().GetCounter(), this);

                bones.ReplaceAllCorpseDynamicFlags((CorpseDynFlags)(byte)corpse.CorpseData.DynamicFlags);
                bones.SetOwnerGUID(corpse.CorpseData.Owner);
                bones.SetPartyGUID(corpse.CorpseData.PartyGUID);
                bones.SetGuildGUID(corpse.CorpseData.GuildGUID);
                bones.SetDisplayId(corpse.CorpseData.DisplayID);
                bones.SetRace(corpse.CorpseData.RaceID);
                bones.SetSex(corpse.CorpseData.Sex);
                bones.SetClass(corpse.CorpseData.Class);
                bones.SetCustomizations(corpse.CorpseData.Customizations);
                bones.ReplaceAllFlags((CorpseFlags)(corpse.CorpseData.Flags | (uint)CorpseFlags.Bones));
                bones.SetFactionTemplate(corpse.CorpseData.FactionTemplate);

                for (int i = 0; i < EquipmentSlot.End; ++i)
                    bones.SetItem((uint)i, corpse.CorpseData.Items[i]);

                bones.SetCellCoord(corpse.GetCellCoord());
                bones.Relocate(corpse.GetPositionX(), corpse.GetPositionY(), corpse.GetPositionZ(), corpse.GetOrientation());

                PhasingHandler.InheritPhaseShift(bones, corpse);

                AddCorpse(bones);

                bones.UpdatePositionData();
                bones.SetZoneScript();

                // add bones in grid store if grid loaded where corpse placed
                AddToMap(bones);
            }

            // all references to the corpse should be removed at this point
            corpse.Dispose();

            return bones;
        }

        public void RemoveOldCorpses()
        {
            long now = GameTime.GetGameTime();

            List<ObjectGuid> corpses = new();

            foreach (var p in _corpsesByPlayer)
                if (p.Value.IsExpired(now))
                    corpses.Add(p.Key);

            foreach (ObjectGuid ownerGuid in corpses)
                ConvertCorpseToBones(ownerGuid);

            List<Corpse> expiredBones = new();

            foreach (Corpse bones in _corpseBones)
                if (bones.IsExpired(now))
                    expiredBones.Add(bones);

            foreach (Corpse bones in expiredBones)
            {
                RemoveCorpse(bones);
                bones.Dispose();
            }
        }

        public void SendZoneDynamicInfo(uint zoneId, Player player)
        {
            var zoneInfo = _zoneDynamicInfo.LookupByKey(zoneId);

            if (zoneInfo == null)
                return;

            uint music = zoneInfo.MusicId;

            if (music != 0)
                player.SendPacket(new PlayMusic(music));

            SendZoneWeather(zoneInfo, player);

            foreach (var lightOverride in zoneInfo.LightOverrides)
            {
                OverrideLight overrideLight = new();
                overrideLight.AreaLightID = lightOverride.AreaLightId;
                overrideLight.OverrideLightID = lightOverride.OverrideLightId;
                overrideLight.TransitionMilliseconds = lightOverride.TransitionMilliseconds;
                player.SendPacket(overrideLight);
            }
        }

        public void SendZoneWeather(uint zoneId, Player player)
        {
            if (!player.HasAuraType(AuraType.ForceWeather))
            {
                var zoneInfo = _zoneDynamicInfo.LookupByKey(zoneId);

                if (zoneInfo == null)
                    return;

                SendZoneWeather(zoneInfo, player);
            }
        }

        public void SetZoneMusic(uint zoneId, uint musicId)
        {
            if (!_zoneDynamicInfo.ContainsKey(zoneId))
                _zoneDynamicInfo[zoneId] = new ZoneDynamicInfo();

            _zoneDynamicInfo[zoneId].MusicId = musicId;

            var players = GetPlayers();

            if (!players.Empty())
            {
                PlayMusic playMusic = new(musicId);

                foreach (var player in players)
                    if (player.GetZoneId() == zoneId &&
                        !player.HasAuraType(AuraType.ForceWeather))
                        player.SendPacket(playMusic);
            }
        }

        public Weather GetOrGenerateZoneDefaultWeather(uint zoneId)
        {
            WeatherData weatherData = Global.WeatherMgr.GetWeatherData(zoneId);

            if (weatherData == null)
                return null;

            if (!_zoneDynamicInfo.ContainsKey(zoneId))
                _zoneDynamicInfo[zoneId] = new ZoneDynamicInfo();

            ZoneDynamicInfo info = _zoneDynamicInfo[zoneId];

            if (info.DefaultWeather == null)
            {
                info.DefaultWeather = new Weather(zoneId, weatherData);
                info.DefaultWeather.ReGenerate();
                info.DefaultWeather.UpdateWeather();
            }

            return info.DefaultWeather;
        }

        public WeatherState GetZoneWeather(uint zoneId)
        {
            ZoneDynamicInfo zoneDynamicInfo = _zoneDynamicInfo.LookupByKey(zoneId);

            if (zoneDynamicInfo != null)
            {
                if (zoneDynamicInfo.WeatherId != 0)
                    return zoneDynamicInfo.WeatherId;

                if (zoneDynamicInfo.DefaultWeather != null)
                    return zoneDynamicInfo.DefaultWeather.GetWeatherState();
            }

            return WeatherState.Fine;
        }

        public void SetZoneWeather(uint zoneId, WeatherState weatherId, float intensity)
        {
            if (!_zoneDynamicInfo.ContainsKey(zoneId))
                _zoneDynamicInfo[zoneId] = new ZoneDynamicInfo();

            ZoneDynamicInfo info = _zoneDynamicInfo[zoneId];
            info.WeatherId = weatherId;
            info.Intensity = intensity;

            var players = GetPlayers();

            if (!players.Empty())
            {
                WeatherPkt weather = new(weatherId, intensity);

                foreach (var player in players)
                    if (player.GetZoneId() == zoneId)
                        player.SendPacket(weather);
            }
        }

        public void SetZoneOverrideLight(uint zoneId, uint areaLightId, uint overrideLightId, TimeSpan transitionTime)
        {
            if (!_zoneDynamicInfo.ContainsKey(zoneId))
                _zoneDynamicInfo[zoneId] = new ZoneDynamicInfo();

            ZoneDynamicInfo info = _zoneDynamicInfo[zoneId];
            // client can support only one override for each light (zone independent)
            info.LightOverrides.RemoveAll(lightOverride => lightOverride.AreaLightId == areaLightId);

            // set new override (if any)
            if (overrideLightId != 0)
            {
                ZoneDynamicInfo.LightOverride lightOverride = new();
                lightOverride.AreaLightId = areaLightId;
                lightOverride.OverrideLightId = overrideLightId;
                lightOverride.TransitionMilliseconds = (uint)transitionTime.TotalMilliseconds;
                info.LightOverrides.Add(lightOverride);
            }

            var players = GetPlayers();

            if (!players.Empty())
            {
                OverrideLight overrideLight = new();
                overrideLight.AreaLightID = areaLightId;
                overrideLight.OverrideLightID = overrideLightId;
                overrideLight.TransitionMilliseconds = (uint)transitionTime.TotalMilliseconds;

                foreach (var player in players)
                    if (player.GetZoneId() == zoneId)
                        player.SendPacket(overrideLight);
            }
        }

        public void UpdateAreaDependentAuras()
        {
            var players = GetPlayers();

            foreach (var player in players)
                if (player)
                    if (player.IsInWorld)
                    {
                        player.UpdateAreaDependentAuras(player.GetAreaId());
                        player.UpdateZoneDependentAuras(player.GetZoneId());
                    }
        }

        public virtual string GetDebugInfo()
        {
            return $"Id: {GetId()} InstanceId: {GetInstanceId()} Difficulty: {GetDifficultyID()} HasPlayers: {HavePlayers()}";
        }

        public MapRecord GetEntry()
        {
            return i_mapRecord;
        }

        public bool CanUnload(uint diff)
        {
            if (_unloadTimer == 0)
                return false;

            if (_unloadTimer <= diff)
                return true;

            _unloadTimer -= diff;

            return false;
        }

        public float GetVisibilityRange()
        {
            return _VisibleDistance;
        }

        public bool IsRemovalGrid(float x, float y)
        {
            GridCoord p = GridDefines.ComputeGridCoord(x, y);

            return GetGrid(p.X_coord, p.Y_coord) == null ||
                   GetGrid(p.X_coord, p.Y_coord).GetGridState() == GridState.Removal;
        }

        public bool IsRemovalGrid(Position pos)
        {
            return IsRemovalGrid(pos.GetPositionX(), pos.GetPositionY());
        }

        public void ResetGridExpiry(Grid grid, float factor = 1)
        {
            grid.ResetTimeTracker((long)(i_gridExpiry * factor));
        }

        public long GetGridExpiry()
        {
            return i_gridExpiry;
        }

        public TerrainInfo GetTerrain()
        {
            return _terrain;
        }

        public uint GetInstanceId()
        {
            return i_InstanceId;
        }

        public virtual TransferAbortParams CannotEnter(Player player)
        {
            return null;
        }

        public Difficulty GetDifficultyID()
        {
            return i_spawnMode;
        }

        public MapDifficultyRecord GetMapDifficulty()
        {
            return Global.DB2Mgr.GetMapDifficultyData(GetId(), GetDifficultyID());
        }

        public ItemContext GetDifficultyLootItemContext()
        {
            MapDifficultyRecord mapDifficulty = GetMapDifficulty();

            if (mapDifficulty != null &&
                mapDifficulty.ItemContext != 0)
                return (ItemContext)mapDifficulty.ItemContext;

            DifficultyRecord difficulty = CliDB.DifficultyStorage.LookupByKey(GetDifficultyID());

            if (difficulty != null)
                return (ItemContext)difficulty.ItemContext;

            return ItemContext.None;
        }

        public uint GetId()
        {
            return i_mapRecord.Id;
        }

        public bool Instanceable()
        {
            return i_mapRecord != null && i_mapRecord.Instanceable();
        }

        public bool IsDungeon()
        {
            return i_mapRecord != null && i_mapRecord.IsDungeon();
        }

        public bool IsNonRaidDungeon()
        {
            return i_mapRecord != null && i_mapRecord.IsNonRaidDungeon();
        }

        public bool IsRaid()
        {
            return i_mapRecord != null && i_mapRecord.IsRaid();
        }

        public bool IsHeroic()
        {
            DifficultyRecord difficulty = CliDB.DifficultyStorage.LookupByKey(i_spawnMode);

            if (difficulty != null)
                return difficulty.Flags.HasAnyFlag(DifficultyFlags.Heroic);

            return false;
        }

        public bool Is25ManRaid()
        {
            // since 25man difficulties are 1 and 3, we can check them like that
            return IsRaid() && (i_spawnMode == Difficulty.Raid25N || i_spawnMode == Difficulty.Raid25HC);
        }

        public bool IsBattleground()
        {
            return i_mapRecord != null && i_mapRecord.IsBattleground();
        }

        public bool IsBattleArena()
        {
            return i_mapRecord != null && i_mapRecord.IsBattleArena();
        }

        public bool IsBattlegroundOrArena()
        {
            return i_mapRecord != null && i_mapRecord.IsBattlegroundOrArena();
        }

        public bool IsScenario()
        {
            return i_mapRecord != null && i_mapRecord.IsScenario();
        }

        public bool IsGarrison()
        {
            return i_mapRecord != null && i_mapRecord.IsGarrison();
        }

        public bool HavePlayers()
        {
            return !_activePlayers.Empty();
        }

        public void AddWorldObject(WorldObject obj)
        {
            i_worldObjects.Add(obj);
        }

        public void RemoveWorldObject(WorldObject obj)
        {
            i_worldObjects.Remove(obj);
        }

        public void DoOnPlayers(Action<Player> action)
        {
            foreach (var player in GetPlayers())
                action(player);
        }

        public List<Player> GetPlayers()
        {
            return _activePlayers;
        }

        public int GetActiveNonPlayersCount()
        {
            return _activeNonPlayers.Count;
        }

        public Dictionary<ObjectGuid, WorldObject> GetObjectsStore()
        {
            return _objectsStore;
        }

        public MultiMap<ulong, Creature> GetCreatureBySpawnIdStore()
        {
            return _creatureBySpawnIdStore;
        }

        public MultiMap<ulong, GameObject> GetGameObjectBySpawnIdStore()
        {
            return _gameobjectBySpawnIdStore;
        }

        public MultiMap<ulong, AreaTrigger> GetAreaTriggerBySpawnIdStore()
        {
            return _areaTriggerBySpawnIdStore;
        }

        public List<Corpse> GetCorpsesInCell(uint cellId)
        {
            return _corpsesByCell.LookupByKey(cellId);
        }

        public Corpse GetCorpseByPlayer(ObjectGuid ownerGuid)
        {
            return _corpsesByPlayer.LookupByKey(ownerGuid);
        }

        public InstanceMap ToInstanceMap()
        {
            return IsDungeon() ? (this as InstanceMap) : null;
        }

        public BattlegroundMap ToBattlegroundMap()
        {
            return IsBattlegroundOrArena() ? (this as BattlegroundMap) : null;
        }

        public void Balance()
        {
            _dynamicTree.Balance();
        }

        public void RemoveGameObjectModel(GameObjectModel model)
        {
            _dynamicTree.Remove(model);
        }

        public void InsertGameObjectModel(GameObjectModel model)
        {
            _dynamicTree.Insert(model);
        }

        public bool ContainsGameObjectModel(GameObjectModel model)
        {
            return _dynamicTree.Contains(model);
        }

        public float GetGameObjectFloor(PhaseShift phaseShift, float x, float y, float z, float maxSearchDist = MapConst.DefaultHeightSearch)
        {
            return _dynamicTree.GetHeight(x, y, z, maxSearchDist, phaseShift);
        }

        public virtual uint GetOwnerGuildId(Team team = Team.Other)
        {
            return 0;
        }

        public long GetRespawnTime(SpawnObjectType type, ulong spawnId)
        {
            var map = GetRespawnMapForType(type);

            if (map != null)
            {
                var respawnInfo = map.LookupByKey(spawnId);

                return (respawnInfo == null) ? 0 : respawnInfo.RespawnTime;
            }

            return 0;
        }

        public long GetCreatureRespawnTime(ulong spawnId)
        {
            return GetRespawnTime(SpawnObjectType.Creature, spawnId);
        }

        public long GetGORespawnTime(ulong spawnId)
        {
            return GetRespawnTime(SpawnObjectType.GameObject, spawnId);
        }

        public AreaTrigger GetAreaTrigger(ObjectGuid guid)
        {
            if (!guid.IsAreaTrigger())
                return null;

            return (AreaTrigger)_objectsStore.LookupByKey(guid);
        }

        public SceneObject GetSceneObject(ObjectGuid guid)
        {
            return _objectsStore.LookupByKey(guid) as SceneObject;
        }

        public Conversation GetConversation(ObjectGuid guid)
        {
            return (Conversation)_objectsStore.LookupByKey(guid);
        }

        public Player GetPlayer(ObjectGuid guid)
        {
            return Global.ObjAccessor.GetPlayer(this, guid);
        }

        public Corpse GetCorpse(ObjectGuid guid)
        {
            if (!guid.IsCorpse())
                return null;

            return (Corpse)_objectsStore.LookupByKey(guid);
        }

        public Creature GetCreature(ObjectGuid guid)
        {
            if (!guid.IsCreatureOrVehicle())
                return null;

            return (Creature)_objectsStore.LookupByKey(guid);
        }

        public DynamicObject GetDynamicObject(ObjectGuid guid)
        {
            if (!guid.IsDynamicObject())
                return null;

            return (DynamicObject)_objectsStore.LookupByKey(guid);
        }

        public GameObject GetGameObject(ObjectGuid guid)
        {
            if (!guid.IsAnyTypeGameObject())
                return null;

            return (GameObject)_objectsStore.LookupByKey(guid);
        }

        public Pet GetPet(ObjectGuid guid)
        {
            if (!guid.IsPet())
                return null;

            return (Pet)_objectsStore.LookupByKey(guid);
        }

        public Transport GetTransport(ObjectGuid guid)
        {
            if (!guid.IsMOTransport())
                return null;

            GameObject go = GetGameObject(guid);

            return go ? go.ToTransport() : null;
        }

        public Creature GetCreatureBySpawnId(ulong spawnId)
        {
            var bounds = GetCreatureBySpawnIdStore().LookupByKey(spawnId);

            if (bounds.Empty())
                return null;

            var foundCreature = bounds.Find(creature => creature.IsAlive());

            return foundCreature != null ? foundCreature : bounds[0];
        }

        public GameObject GetGameObjectBySpawnId(ulong spawnId)
        {
            var bounds = GetGameObjectBySpawnIdStore().LookupByKey(spawnId);

            if (bounds.Empty())
                return null;

            var foundGameObject = bounds.Find(gameobject => gameobject.IsSpawned());

            return foundGameObject != null ? foundGameObject : bounds[0];
        }

        public AreaTrigger GetAreaTriggerBySpawnId(ulong spawnId)
        {
            var bounds = GetAreaTriggerBySpawnIdStore().LookupByKey(spawnId);

            if (bounds.Empty())
                return null;

            return bounds.FirstOrDefault();
        }

        public WorldObject GetWorldObjectBySpawnId(SpawnObjectType type, ulong spawnId)
        {
            switch (type)
            {
                case SpawnObjectType.Creature:
                    return GetCreatureBySpawnId(spawnId);
                case SpawnObjectType.GameObject:
                    return GetGameObjectBySpawnId(spawnId);
                case SpawnObjectType.AreaTrigger:
                    return GetAreaTriggerBySpawnId(spawnId);
                default:
                    return null;
            }
        }

        public void Visit(Cell cell, Visitor visitor)
        {
            uint x = cell.GetGridX();
            uint y = cell.GetGridY();
            uint cell_x = cell.GetCellX();
            uint cell_y = cell.GetCellY();

            if (!cell.NoCreate() ||
                IsGridLoaded(new GridCoord(x, y)))
            {
                EnsureGridLoaded(cell);
                GetGrid(x, y).VisitGrid(cell_x, cell_y, visitor);
            }
        }

        public TempSummon SummonCreature(uint entry, Position pos, SummonPropertiesRecord properties = null, uint duration = 0, WorldObject summoner = null, uint spellId = 0, uint vehId = 0, ObjectGuid privateObjectOwner = default, SmoothPhasingInfo smoothPhasingInfo = null)
        {
            var mask = UnitTypeMask.Summon;

            if (properties != null)
                switch (properties.Control)
                {
                    case SummonCategory.Pet:
                        mask = UnitTypeMask.Guardian;

                        break;
                    case SummonCategory.Puppet:
                        mask = UnitTypeMask.Puppet;

                        break;
                    case SummonCategory.Vehicle:
                        mask = UnitTypeMask.Minion;

                        break;
                    case SummonCategory.Wild:
                    case SummonCategory.Ally:
                    case SummonCategory.Unk:
                        {
                            switch (properties.Title)
                            {
                                case SummonTitle.Minion:
                                case SummonTitle.Guardian:
                                case SummonTitle.Runeblade:
                                    mask = UnitTypeMask.Guardian;

                                    break;
                                case SummonTitle.Totem:
                                case SummonTitle.LightWell:
                                    mask = UnitTypeMask.Totem;

                                    break;
                                case SummonTitle.Vehicle:
                                case SummonTitle.Mount:
                                    mask = UnitTypeMask.Summon;

                                    break;
                                case SummonTitle.Companion:
                                    mask = UnitTypeMask.Minion;

                                    break;
                                default:
                                    if (properties.GetFlags().HasFlag(SummonPropertiesFlags.JoinSummonerSpawnGroup)) // Mirror Image, Summon Gargoyle
                                        mask = UnitTypeMask.Guardian;

                                    break;
                            }

                            break;
                        }
                    default:
                        return null;
                }

            Unit summonerUnit = summoner?.ToUnit();

            TempSummon summon;

            switch (mask)
            {
                case UnitTypeMask.Summon:
                    summon = new TempSummon(properties, summonerUnit, false);

                    break;
                case UnitTypeMask.Guardian:
                    summon = new Guardian(properties, summonerUnit, false);

                    break;
                case UnitTypeMask.Puppet:
                    summon = new Puppet(properties, summonerUnit);

                    break;
                case UnitTypeMask.Totem:
                    summon = new Totem(properties, summonerUnit);

                    break;
                case UnitTypeMask.Minion:
                    summon = new Minion(properties, summonerUnit, false);

                    break;
                default:
                    return null;
            }

            if (!summon.Create(GenerateLowGuid(HighGuid.Creature), this, entry, pos, null, vehId, true))
                return null;

            ITransport transport = summoner?.GetTransport();

            if (transport != null)
            {
                pos.GetPosition(out float x, out float y, out float z, out float o);
                transport.CalculatePassengerOffset(ref x, ref y, ref z, ref o);
                summon.MovementInfo.Transport.Pos.Relocate(x, y, z, o);

                // This object must be added to Transport before adding to map for the client to properly display it
                transport.AddPassenger(summon);
            }

            // Set the summon to the summoner's phase
            if (summoner != null &&
                !(properties != null && properties.GetFlags().HasFlag(SummonPropertiesFlags.IgnoreSummonerPhase)))
                PhasingHandler.InheritPhaseShift(summon, summoner);

            summon.SetCreatedBySpell(spellId);
            summon.SetHomePosition(pos);
            summon.InitStats(duration);
            summon.SetPrivateObjectOwner(privateObjectOwner);

            if (smoothPhasingInfo != null)
            {
                if (summoner != null &&
                    smoothPhasingInfo.ReplaceObject.HasValue)
                {
                    WorldObject replacedObject = Global.ObjAccessor.GetWorldObject(summoner, smoothPhasingInfo.ReplaceObject.Value);

                    if (replacedObject != null)
                    {
                        SmoothPhasingInfo originalSmoothPhasingInfo = smoothPhasingInfo;
                        originalSmoothPhasingInfo.ReplaceObject = summon.GetGUID();
                        replacedObject.GetOrCreateSmoothPhasing().SetViewerDependentInfo(privateObjectOwner, originalSmoothPhasingInfo);

                        summon.SetDemonCreatorGUID(privateObjectOwner);
                    }
                }

                summon.GetOrCreateSmoothPhasing().SetSingleInfo(smoothPhasingInfo);
            }

            if (!AddToMap(summon.ToCreature()))
            {
                // Returning false will cause the object to be deleted - remove from Transport
                transport?.RemovePassenger(summon);

                summon.Dispose();

                return null;
            }

            summon.InitSummon();

            // call MoveInLineOfSight for nearby creatures
            AIRelocationNotifier notifier = new(summon);
            Cell.VisitAllObjects(summon, notifier, GetVisibilityRange());

            return summon;
        }

        public ulong GenerateLowGuid(HighGuid high)
        {
            return GetGuidSequenceGenerator(high).Generate();
        }

        public ulong GetMaxLowGuid(HighGuid high)
        {
            return GetGuidSequenceGenerator(high).GetNextAfterMaxUsed();
        }

        public void AddUpdateObject(WorldObject obj)
        {
            _updateObjects.Add(obj);
        }

        public void RemoveUpdateObject(WorldObject obj)
        {
            _updateObjects.Remove(obj);
        }

        public static implicit operator bool(Map map)
        {
            return map != null;
        }

        public MultiPersonalPhaseTracker GetMultiPersonalPhaseTracker()
        {
            return _multiPersonalPhaseTracker;
        }

        public SpawnedPoolData GetPoolData()
        {
            return _poolData;
        }

        private void SwitchGridContainers(WorldObject obj, bool on)
        {
            if (obj.IsPermanentWorldObject())
                return;

            CellCoord p = GridDefines.ComputeCellCoord(obj.GetPositionX(), obj.GetPositionY());

            if (!p.IsCoordValid())
            {
                Log.outError(LogFilter.Maps,
                             "Map.SwitchGridContainers: Object {0} has invalid coordinates X:{1} Y:{2} grid cell [{3}:{4}]",
                             obj.GetGUID(),
                             obj.GetPositionX(),
                             obj.GetPositionY(),
                             p.X_coord,
                             p.Y_coord);

                return;
            }

            var cell = new Cell(p);

            if (!IsGridLoaded(new GridCoord(cell.GetGridX(), cell.GetGridY())))
                return;

            Log.outDebug(LogFilter.Maps, "Switch object {0} from grid[{1}, {2}] {3}", obj.GetGUID(), cell.GetGridX(), cell.GetGridY(), on);
            Grid ngrid = GetGrid(cell.GetGridX(), cell.GetGridY());
            Cypher.Assert(ngrid != null);

            RemoveFromGrid(obj, cell);

            GridCell gridCell = ngrid.GetGridCell(cell.GetCellX(), cell.GetCellY());

            if (on)
            {
                gridCell.AddWorldObject(obj);
                AddWorldObject(obj);
            }
            else
            {
                gridCell.AddGridObject(obj);
                RemoveWorldObject(obj);
            }

            obj.SetCurrentCell(cell);
            obj.ToCreature().IsTempWorldObject = on;
        }

        private void DeleteFromWorld(Player player)
        {
            Global.ObjAccessor.RemoveObject(player);
            RemoveUpdateObject(player); // @todo I do not know why we need this, it should be removed in ~Object anyway
            player.Dispose();
        }

        private void DeleteFromWorld(WorldObject obj)
        {
            obj.Dispose();
        }

        private void EnsureGridCreated(GridCoord p)
        {
            if (GetGrid(p.X_coord, p.Y_coord) == null)
            {
                Log.outDebug(LogFilter.Maps,
                             "Creating grid[{0}, {1}] for map {2} instance {3}",
                             p.X_coord,
                             p.Y_coord,
                             GetId(),
                             i_InstanceId);

                var grid = new Grid(p.X_coord * MapConst.MaxGrids + p.Y_coord, p.X_coord, p.Y_coord, i_gridExpiry, WorldConfig.GetBoolValue(WorldCfg.GridUnload));
                grid.SetGridState(GridState.Idle);
                SetGrid(grid, p.X_coord, p.Y_coord);

                //z coord
                int gx = (int)((MapConst.MaxGrids - 1) - p.X_coord);
                int gy = (int)((MapConst.MaxGrids - 1) - p.Y_coord);

                _terrain.LoadMapAndVMap(gx, gy);
            }
        }

        private void EnsureGridLoadedForActiveObject(Cell cell, WorldObject obj)
        {
            EnsureGridLoaded(cell);
            Grid grid = GetGrid(cell.GetGridX(), cell.GetGridY());

            if (obj.IsPlayer())
                GetMultiPersonalPhaseTracker().LoadGrid(obj.GetPhaseShift(), grid, this, cell);

            // refresh grid State & timer
            if (grid.GetGridState() != GridState.Active)
            {
                Log.outDebug(LogFilter.Maps,
                             "Active object {0} triggers loading of grid [{1}, {2}] on map {3}",
                             obj.GetGUID(),
                             cell.GetGridX(),
                             cell.GetGridY(),
                             GetId());

                ResetGridExpiry(grid, 0.1f);
                grid.SetGridState(GridState.Active);
            }
        }

        private bool EnsureGridLoaded(Cell cell)
        {
            EnsureGridCreated(new GridCoord(cell.GetGridX(), cell.GetGridY()));
            Grid grid = GetGrid(cell.GetGridX(), cell.GetGridY());

            if (!IsGridObjectDataLoaded(cell.GetGridX(), cell.GetGridY()))
            {
                Log.outDebug(LogFilter.Maps,
                             "Loading grid[{0}, {1}] for map {2} instance {3}",
                             cell.GetGridX(),
                             cell.GetGridY(),
                             GetId(),
                             i_InstanceId);

                SetGridObjectDataLoaded(true, cell.GetGridX(), cell.GetGridY());

                LoadGridObjects(grid, cell);

                Balance();

                return true;
            }

            return false;
        }

        private void GridMarkNoUnload(uint x, uint y)
        {
            // First make sure this grid is loaded
            float gX = (((float)x - 0.5f - MapConst.CenterGridId) * MapConst.SizeofGrids) + (MapConst.CenterGridOffset * 2);
            float gY = (((float)y - 0.5f - MapConst.CenterGridId) * MapConst.SizeofGrids) + (MapConst.CenterGridOffset * 2);
            Cell cell = new(gX, gY);
            EnsureGridLoaded(cell);

            // Mark as don't unload
            var grid = GetGrid(x, y);
            grid.SetUnloadExplicitLock(true);
        }

        private void GridUnmarkNoUnload(uint x, uint y)
        {
            // If grid is loaded, clear unload lock
            if (IsGridLoaded(new GridCoord(x, y)))
            {
                var grid = GetGrid(x, y);
                grid.SetUnloadExplicitLock(false);
            }
        }

        private void InitializeObject(WorldObject obj)
        {
            if (!obj.IsTypeId(TypeId.Unit) ||
                !obj.IsTypeId(TypeId.GameObject))
                return;

            obj.MoveState = ObjectCellMoveState.None;
        }

        private void VisitNearbyCellsOf(WorldObject obj, Visitor gridVisitor, Visitor worldVisitor)
        {
            // Check for valid position
            if (!obj.IsPositionValid())
                return;

            // Update mobs/objects in ALL visible cells around object!
            CellArea area = Cell.CalculateCellArea(obj.GetPositionX(), obj.GetPositionY(), obj.GetGridActivationRange());

            for (uint x = area.Low_bound.X_coord; x <= area.High_bound.X_coord; ++x)
            {
                for (uint y = area.Low_bound.Y_coord; y <= area.High_bound.Y_coord; ++y)
                {
                    // marked cells are those that have been visited
                    // don't visit the same cell twice
                    uint cell_id = (y * MapConst.TotalCellsPerMap) + x;

                    if (IsCellMarked(cell_id))
                        continue;

                    MarkCell(cell_id);
                    var pair = new CellCoord(x, y);
                    var cell = new Cell(pair);
                    cell.SetNoCreate();
                    Visit(cell, gridVisitor);
                    Visit(cell, worldVisitor);
                }
            }
        }

        private void ProcessRelocationNotifies(uint diff)
        {
            for (uint x = 0; x < MapConst.MaxGrids; ++x)
            {
                for (uint y = 0; y < MapConst.MaxGrids; ++y)
                {
                    Grid grid = GetGrid(x, y);

                    if (grid == null)
                        continue;

                    if (grid.GetGridState() != GridState.Active)
                        continue;

                    grid.GetGridInfoRef().GetRelocationTimer().TUpdate((int)diff);

                    if (!grid.GetGridInfoRef().GetRelocationTimer().TPassed())
                        continue;

                    uint gx = grid.GetX();
                    uint gy = grid.GetY();

                    var cell_min = new CellCoord(gx * MapConst.MaxCells, gy * MapConst.MaxCells);
                    var cell_max = new CellCoord(cell_min.X_coord + MapConst.MaxCells, cell_min.Y_coord + MapConst.MaxCells);

                    for (uint xx = cell_min.X_coord; xx < cell_max.X_coord; ++xx)
                    {
                        for (uint yy = cell_min.Y_coord; yy < cell_max.Y_coord; ++yy)
                        {
                            uint cell_id = (yy * MapConst.TotalCellsPerMap) + xx;

                            if (!IsCellMarked(cell_id))
                                continue;

                            var pair = new CellCoord(xx, yy);
                            var cell = new Cell(pair);
                            cell.SetNoCreate();

                            var cell_relocation = new DelayedUnitRelocation(cell, pair, this, SharedConst.MaxVisibilityDistance);
                            var grid_object_relocation = new Visitor(cell_relocation, GridMapTypeMask.AllGrid);
                            var world_object_relocation = new Visitor(cell_relocation, GridMapTypeMask.AllWorld);

                            Visit(cell, grid_object_relocation);
                            Visit(cell, world_object_relocation);
                        }
                    }
                }
            }

            var reset = new ResetNotifier();
            var grid_notifier = new Visitor(reset, GridMapTypeMask.AllGrid);
            var world_notifier = new Visitor(reset, GridMapTypeMask.AllWorld);

            for (uint x = 0; x < MapConst.MaxGrids; ++x)
            {
                for (uint y = 0; y < MapConst.MaxGrids; ++y)
                {
                    Grid grid = GetGrid(x, y);

                    if (grid == null)
                        continue;

                    if (grid.GetGridState() != GridState.Active)
                        continue;

                    if (!grid.GetGridInfoRef().GetRelocationTimer().TPassed())
                        continue;

                    grid.GetGridInfoRef().GetRelocationTimer().TReset((int)diff, _VisibilityNotifyPeriod);

                    uint gx = grid.GetX();
                    uint gy = grid.GetY();

                    var cell_min = new CellCoord(gx * MapConst.MaxCells, gy * MapConst.MaxCells);

                    var cell_max = new CellCoord(cell_min.X_coord + MapConst.MaxCells,
                                                 cell_min.Y_coord + MapConst.MaxCells);

                    for (uint xx = cell_min.X_coord; xx < cell_max.X_coord; ++xx)
                    {
                        for (uint yy = cell_min.Y_coord; yy < cell_max.Y_coord; ++yy)
                        {
                            uint cell_id = (yy * MapConst.TotalCellsPerMap) + xx;

                            if (!IsCellMarked(cell_id))
                                continue;

                            var pair = new CellCoord(xx, yy);
                            var cell = new Cell(pair);
                            cell.SetNoCreate();
                            Visit(cell, grid_notifier);
                            Visit(cell, world_notifier);
                        }
                    }
                }
            }
        }

        private bool CheckGridIntegrity<T>(T obj, bool moved) where T : WorldObject
        {
            Cell cur_cell = obj.GetCurrentCell();
            Cell xy_cell = new(obj.GetPositionX(), obj.GetPositionY());

            if (xy_cell != cur_cell)
            {
                //$"grid[{GetGridX()}, {GetGridY()}]cell[{GetCellX()}, {GetCellY()}]";
                Log.outDebug(LogFilter.Maps, $"{obj.GetTypeId()} ({obj.GetGUID()}) X: {obj.GetPositionX()} Y: {obj.GetPositionY()} ({(moved ? "final" : "original")}) is in {cur_cell} instead of {xy_cell}");

                return true; // not crash at error, just output error in debug mode
            }

            return true;
        }

        private void AddCreatureToMoveList(Creature c, float x, float y, float z, float ang)
        {
            if (_creatureToMoveLock) //can this happen?
                return;

            if (c.MoveState == ObjectCellMoveState.None)
                creaturesToMove.Add(c);

            c.SetNewCellPosition(x, y, z, ang);
        }

        private void AddGameObjectToMoveList(GameObject go, float x, float y, float z, float ang)
        {
            if (_gameObjectsToMoveLock) //can this happen?
                return;

            if (go.MoveState == ObjectCellMoveState.None)
                _gameObjectsToMove.Add(go);

            go.SetNewCellPosition(x, y, z, ang);
        }

        private void RemoveGameObjectFromMoveList(GameObject go)
        {
            if (_gameObjectsToMoveLock) //can this happen?
                return;

            if (go.MoveState == ObjectCellMoveState.Active)
                go.MoveState = ObjectCellMoveState.Inactive;
        }

        private void RemoveCreatureFromMoveList(Creature c)
        {
            if (_creatureToMoveLock) //can this happen?
                return;

            if (c.MoveState == ObjectCellMoveState.Active)
                c.MoveState = ObjectCellMoveState.Inactive;
        }

        private void AddDynamicObjectToMoveList(DynamicObject dynObj, float x, float y, float z, float ang)
        {
            if (_dynamicObjectsToMoveLock) //can this happen?
                return;

            if (dynObj.MoveState == ObjectCellMoveState.None)
                _dynamicObjectsToMove.Add(dynObj);

            dynObj.SetNewCellPosition(x, y, z, ang);
        }

        private void RemoveDynamicObjectFromMoveList(DynamicObject dynObj)
        {
            if (_dynamicObjectsToMoveLock) //can this happen?
                return;

            if (dynObj.MoveState == ObjectCellMoveState.Active)
                dynObj.MoveState = ObjectCellMoveState.Inactive;
        }

        private void AddAreaTriggerToMoveList(AreaTrigger at, float x, float y, float z, float ang)
        {
            if (_areaTriggersToMoveLock) //can this happen?
                return;

            if (at.MoveState == ObjectCellMoveState.None)
                _areaTriggersToMove.Add(at);

            at.SetNewCellPosition(x, y, z, ang);
        }

        private void RemoveAreaTriggerFromMoveList(AreaTrigger at)
        {
            if (_areaTriggersToMoveLock) //can this happen?
                return;

            if (at.MoveState == ObjectCellMoveState.Active)
                at.MoveState = ObjectCellMoveState.Inactive;
        }

        private void MoveAllCreaturesInMoveList()
        {
            _creatureToMoveLock = true;

            for (var i = 0; i < creaturesToMove.Count; ++i)
            {
                Creature creature = creaturesToMove[i];

                if (creature.GetMap() != this) //pet is teleported to another map
                    continue;

                if (creature.MoveState != ObjectCellMoveState.Active)
                {
                    creature.MoveState = ObjectCellMoveState.None;

                    continue;
                }

                creature.MoveState = ObjectCellMoveState.None;

                if (!creature.IsInWorld)
                    continue;

                // do move or do move to respawn or remove creature if previous all fail
                if (CreatureCellRelocation(creature, new Cell(creature.NewPosition.X, creature.NewPosition.Y)))
                {
                    // update Pos
                    creature.Relocate(creature.NewPosition);

                    if (creature.IsVehicle())
                        creature.GetVehicleKit().RelocatePassengers();

                    creature.UpdatePositionData();
                    creature.UpdateObjectVisibility(false);
                }
                else
                {
                    // if creature can't be move in new cell/grid (not loaded) move it to repawn cell/grid
                    // creature coordinates will be updated and notifiers send
                    if (!CreatureRespawnRelocation(creature, false))
                    {
                        // ... or unload (if respawn grid also not loaded)
                        //This may happen when a player just logs in and a pet moves to a nearby unloaded cell
                        //To avoid this, we can load nearby cells when player log in
                        //But this check is always needed to ensure safety
                        // @todo pets will disappear if this is outside CreatureRespawnRelocation
                        //need to check why pet is frequently relocated to an unloaded cell
                        if (creature.IsPet())
                            ((Pet)creature).Remove(PetSaveMode.NotInSlot, true);
                        else
                            AddObjectToRemoveList(creature);
                    }
                }
            }

            creaturesToMove.Clear();
            _creatureToMoveLock = false;
        }

        private void MoveAllGameObjectsInMoveList()
        {
            _gameObjectsToMoveLock = true;

            for (var i = 0; i < _gameObjectsToMove.Count; ++i)
            {
                GameObject go = _gameObjectsToMove[i];

                if (go.GetMap() != this) //Transport is teleported to another map
                    continue;

                if (go.MoveState != ObjectCellMoveState.Active)
                {
                    go.MoveState = ObjectCellMoveState.None;

                    continue;
                }

                go.MoveState = ObjectCellMoveState.None;

                if (!go.IsInWorld)
                    continue;

                // do move or do move to respawn or remove creature if previous all fail
                if (GameObjectCellRelocation(go, new Cell(go.NewPosition.X, go.NewPosition.Y)))
                {
                    // update Pos
                    go.Relocate(go.NewPosition);
                    go.AfterRelocation();
                }
                else
                {
                    // if GameObject can't be move in new cell/grid (not loaded) move it to repawn cell/grid
                    // GameObject coordinates will be updated and notifiers send
                    if (!GameObjectRespawnRelocation(go, false))
                    {
                        // ... or unload (if respawn grid also not loaded)
                        Log.outDebug(LogFilter.Maps,
                                     "GameObject (GUID: {0} Entry: {1}) cannot be move to unloaded respawn grid.",
                                     go.GetGUID().ToString(),
                                     go.GetEntry());

                        AddObjectToRemoveList(go);
                    }
                }
            }

            _gameObjectsToMove.Clear();
            _gameObjectsToMoveLock = false;
        }

        private void MoveAllDynamicObjectsInMoveList()
        {
            _dynamicObjectsToMoveLock = true;

            for (var i = 0; i < _dynamicObjectsToMove.Count; ++i)
            {
                DynamicObject dynObj = _dynamicObjectsToMove[i];

                if (dynObj.GetMap() != this) //Transport is teleported to another map
                    continue;

                if (dynObj.MoveState != ObjectCellMoveState.Active)
                {
                    dynObj.MoveState = ObjectCellMoveState.None;

                    continue;
                }

                dynObj.MoveState = ObjectCellMoveState.None;

                if (!dynObj.IsInWorld)
                    continue;

                // do move or do move to respawn or remove creature if previous all fail
                if (DynamicObjectCellRelocation(dynObj, new Cell(dynObj.NewPosition.X, dynObj.NewPosition.Y)))
                {
                    // update Pos
                    dynObj.Relocate(dynObj.NewPosition);
                    dynObj.UpdatePositionData();
                    dynObj.UpdateObjectVisibility(false);
                }
                else
                {
                    Log.outDebug(LogFilter.Maps, "DynamicObject (GUID: {0}) cannot be moved to unloaded grid.", dynObj.GetGUID().ToString());
                }
            }

            _dynamicObjectsToMove.Clear();
            _dynamicObjectsToMoveLock = false;
        }

        private void MoveAllAreaTriggersInMoveList()
        {
            _areaTriggersToMoveLock = true;

            for (var i = 0; i < _areaTriggersToMove.Count; ++i)
            {
                AreaTrigger at = _areaTriggersToMove[i];

                if (at.GetMap() != this) //Transport is teleported to another map
                    continue;

                if (at.MoveState != ObjectCellMoveState.Active)
                {
                    at.MoveState = ObjectCellMoveState.None;

                    continue;
                }

                at.MoveState = ObjectCellMoveState.None;

                if (!at.IsInWorld)
                    continue;

                // do move or do move to respawn or remove creature if previous all fail
                if (AreaTriggerCellRelocation(at, new Cell(at.NewPosition.X, at.NewPosition.Y)))
                {
                    // update Pos
                    at.Relocate(at.NewPosition);
                    at.UpdateShape();
                    at.UpdateObjectVisibility(false);
                }
                else
                {
                    Log.outDebug(LogFilter.Maps, "AreaTrigger ({0}) cannot be moved to unloaded grid.", at.GetGUID().ToString());
                }
            }

            _areaTriggersToMove.Clear();
            _areaTriggersToMoveLock = false;
        }

        private bool MapObjectCellRelocation<T>(T obj, Cell new_cell) where T : WorldObject
        {
            Cell old_cell = obj.GetCurrentCell();

            if (!old_cell.DiffGrid(new_cell)) // in same grid
            {
                // if in same cell then none do
                if (old_cell.DiffCell(new_cell))
                {
                    RemoveFromGrid(obj, old_cell);
                    AddToGrid(obj, new_cell);
                }

                return true;
            }

            // in diff. grids but active creature
            if (obj.IsActiveObject())
            {
                EnsureGridLoadedForActiveObject(new_cell, obj);

                Log.outDebug(LogFilter.Maps,
                             "Active creature (GUID: {0} Entry: {1}) moved from grid[{2}, {3}] to grid[{4}, {5}].",
                             obj.GetGUID().ToString(),
                             obj.GetEntry(),
                             old_cell.GetGridX(),
                             old_cell.GetGridY(),
                             new_cell.GetGridX(),
                             new_cell.GetGridY());

                RemoveFromGrid(obj, old_cell);
                AddToGrid(obj, new_cell);

                return true;
            }

            Creature c = obj.ToCreature();

            if (c != null &&
                c.GetCharmerOrOwnerGUID().IsPlayer())
                EnsureGridLoaded(new_cell);

            // in diff. loaded grid normal creature
            var grid = new GridCoord(new_cell.GetGridX(), new_cell.GetGridY());

            if (IsGridLoaded(grid))
            {
                RemoveFromGrid(obj, old_cell);
                EnsureGridCreated(grid);
                AddToGrid(obj, new_cell);

                return true;
            }

            // fail to move: normal creature attempt move to unloaded grid
            return false;
        }

        private bool CreatureCellRelocation(Creature c, Cell new_cell)
        {
            return MapObjectCellRelocation(c, new_cell);
        }

        private bool GameObjectCellRelocation(GameObject go, Cell new_cell)
        {
            return MapObjectCellRelocation(go, new_cell);
        }

        private bool DynamicObjectCellRelocation(DynamicObject go, Cell new_cell)
        {
            return MapObjectCellRelocation(go, new_cell);
        }

        private bool AreaTriggerCellRelocation(AreaTrigger at, Cell new_cell)
        {
            return MapObjectCellRelocation(at, new_cell);
        }

        private bool GetAreaInfo(PhaseShift phaseShift, float x, float y, float z, out uint mogpflags, out int adtId, out int rootId, out int groupId)
        {
            return _terrain.GetAreaInfo(phaseShift, GetId(), x, y, z, out mogpflags, out adtId, out rootId, out groupId, _dynamicTree);
        }

        private void SendInitTransports(Player player)
        {
            var transData = new UpdateData(GetId());

            foreach (Transport transport in _transports)
                if (transport.IsInWorld &&
                    transport != player.GetTransport() &&
                    player.InSamePhase(transport))
                {
                    transport.BuildCreateUpdateBlockForPlayer(transData, player);
                    player.VisibleTransports.Add(transport.GetGUID());
                }

            UpdateObject packet;
            transData.BuildPacket(out packet);
            player.SendPacket(packet);
        }

        private void SendRemoveTransports(Player player)
        {
            var transData = new UpdateData(player.GetMapId());

            foreach (Transport transport in _transports)
                if (player.VisibleTransports.Contains(transport.GetGUID()) &&
                    transport != player.GetTransport())
                {
                    transport.BuildOutOfRangeUpdateBlock(transData);
                    player.VisibleTransports.Remove(transport.GetGUID());
                }

            UpdateObject packet;
            transData.BuildPacket(out packet);
            player.SendPacket(packet);
        }

        private void SetGrid(Grid grid, uint x, uint y)
        {
            if (x >= MapConst.MaxGrids ||
                y >= MapConst.MaxGrids)
            {
                Log.outError(LogFilter.Maps, "Map.setNGrid Invalid grid coordinates found: {0}, {1}!", x, y);

                return;
            }

            i_grids[x][y] = grid;
        }

        private void SendObjectUpdates()
        {
            Dictionary<Player, UpdateData> update_players = new();

            while (!_updateObjects.Empty())
            {
                WorldObject obj = _updateObjects[0];
                Cypher.Assert(obj.IsInWorld);
                _updateObjects.RemoveAt(0);
                obj.BuildUpdate(update_players);
            }

            UpdateObject packet;

            foreach (var iter in update_players)
            {
                iter.Value.BuildPacket(out packet);
                iter.Key.SendPacket(packet);
            }
        }

        private bool CheckRespawn(RespawnInfo info)
        {
            SpawnData data = Global.ObjectMgr.GetSpawnData(info.Type, info.SpawnId);
            Cypher.Assert(data != null, $"Invalid respawn info with Type {info.Type}, spawnID {info.SpawnId} in respawn queue.");

            // First, check if this creature's spawn group is inactive
            if (!IsSpawnGroupActive(data.spawnGroupData.groupId))
            {
                info.RespawnTime = 0;

                return false;
            }

            // Next, check if there's already an instance of this object that would block the respawn
            // Only do this for unpooled spawns
            bool alreadyExists = false;

            switch (info.Type)
            {
                case SpawnObjectType.Creature:
                    {
                        // escort check for creatures only (if the world config boolean is set)
                        bool isEscort = WorldConfig.GetBoolValue(WorldCfg.RespawnDynamicEscortNpc) && data.spawnGroupData.flags.HasFlag(SpawnGroupFlags.EscortQuestNpc);

                        var range = _creatureBySpawnIdStore.LookupByKey(info.SpawnId);

                        foreach (var creature in range)
                        {
                            if (!creature.IsAlive())
                                continue;

                            // escort NPCs are allowed to respawn as long as all other instances are already escorting
                            if (isEscort && creature.IsEscorted())
                                continue;

                            alreadyExists = true;

                            break;
                        }

                        break;
                    }
                case SpawnObjectType.GameObject:
                    // gameobject check is simpler - they cannot be dead or escorting
                    if (_gameobjectBySpawnIdStore.ContainsKey(info.SpawnId))
                        alreadyExists = true;

                    break;
                default:
                    Cypher.Assert(false, $"Invalid spawn Type {info.Type} with spawnId {info.SpawnId} on map {GetId()}");

                    return true;
            }

            if (alreadyExists)
            {
                info.RespawnTime = 0;

                return false;
            }

            // next, check linked respawn Time
            ObjectGuid thisGUID = info.Type == SpawnObjectType.GameObject ? ObjectGuid.Create(HighGuid.GameObject, GetId(), info.Entry, info.SpawnId) : ObjectGuid.Create(HighGuid.Creature, GetId(), info.Entry, info.SpawnId);
            long linkedTime = GetLinkedRespawnTime(thisGUID);

            if (linkedTime != 0)
            {
                long now = GameTime.GetGameTime();
                long respawnTime;

                if (linkedTime == long.MaxValue)
                    respawnTime = linkedTime;
                else if (Global.ObjectMgr.GetLinkedRespawnGuid(thisGUID) == thisGUID) // never respawn, save "something" in DB
                    respawnTime = now + Time.Week;
                else // set us to check again shortly after linked unit
                    respawnTime = Math.Max(now, linkedTime) + RandomHelper.URand(5, 15);

                info.RespawnTime = respawnTime;

                return false;
            }

            // everything ok, let's spawn
            return true;
        }

        private int DespawnAll(SpawnObjectType type, ulong spawnId)
        {
            List<WorldObject> toUnload = new();

            switch (type)
            {
                case SpawnObjectType.Creature:
                    foreach (var creature in GetCreatureBySpawnIdStore().LookupByKey(spawnId))
                        toUnload.Add(creature);

                    break;
                case SpawnObjectType.GameObject:
                    foreach (var obj in GetGameObjectBySpawnIdStore().LookupByKey(spawnId))
                        toUnload.Add(obj);

                    break;
                default:
                    break;
            }

            foreach (WorldObject o in toUnload)
                AddObjectToRemoveList(o);

            return toUnload.Count;
        }

        private bool AddRespawnInfo(RespawnInfo info)
        {
            if (info.SpawnId == 0)
            {
                Log.outError(LogFilter.Maps, $"Attempt to insert respawn info for zero spawn Id (Type {info.Type})");

                return false;
            }

            var bySpawnIdMap = GetRespawnMapForType(info.Type);

            if (bySpawnIdMap == null)
                return false;

            // check if we already have the maximum possible number of respawns scheduled
            if (SpawnMetadata.TypeHasData(info.Type))
            {
                var existing = bySpawnIdMap.LookupByKey(info.SpawnId);

                if (existing != null) // spawnid already has a respawn scheduled
                {
                    if (info.RespawnTime <= existing.RespawnTime) // delete existing in this case
                        DeleteRespawnInfo(existing);
                    else
                        return false;
                }

                Cypher.Assert(!bySpawnIdMap.ContainsKey(info.SpawnId), $"Insertion of respawn info with Id ({info.Type},{info.SpawnId}) into spawn Id map failed - State desync.");
            }
            else
            {
                Cypher.Assert(false, $"Invalid respawn info for spawn Id ({info.Type},{info.SpawnId}) being inserted");
            }

            RespawnInfo ri = new(info);
            _respawnTimes.Add(ri);
            bySpawnIdMap.Add(ri.SpawnId, ri);

            return true;
        }

        private static void PushRespawnInfoFrom(List<RespawnInfo> data, Dictionary<ulong, RespawnInfo> map)
        {
            foreach (var pair in map)
                data.Add(pair.Value);
        }

        private Dictionary<ulong, RespawnInfo> GetRespawnMapForType(SpawnObjectType type)
        {
            switch (type)
            {
                case SpawnObjectType.Creature:
                    return _creatureRespawnTimesBySpawnId;
                case SpawnObjectType.GameObject:
                    return _gameObjectRespawnTimesBySpawnId;
                case SpawnObjectType.AreaTrigger:
                    return null;
                default:
                    Cypher.Assert(false);

                    return null;
            }
        }

        private void UnloadAllRespawnInfos() // delete everything from memory
        {
            _respawnTimes.Clear();
            _creatureRespawnTimesBySpawnId.Clear();
            _gameObjectRespawnTimesBySpawnId.Clear();
        }

        private void DeleteRespawnInfo(RespawnInfo info, SQLTransaction dbTrans = null)
        {
            // Delete from all relevant containers to ensure consistency
            Cypher.Assert(info != null);

            // spawnid store
            var spawnMap = GetRespawnMapForType(info.Type);

            if (spawnMap == null)
                return;

            var respawnInfo = spawnMap.LookupByKey(info.SpawnId);
            Cypher.Assert(respawnInfo != null, $"Respawn stores inconsistent for map {GetId()}, spawnid {info.SpawnId} (Type {info.Type})");
            spawnMap.Remove(info.SpawnId);

            // respawn heap
            _respawnTimes.Remove(info);

            // database
            DeleteRespawnInfoFromDB(info.Type, info.SpawnId, dbTrans);
        }

        private void DeleteRespawnInfoFromDB(SpawnObjectType type, ulong spawnId, SQLTransaction dbTrans = null)
        {
            if (Instanceable())
                return;

            PreparedStatement stmt = DB.Characters.GetPreparedStatement(CharStatements.DEL_RESPAWN);
            stmt.AddValue(0, (ushort)type);
            stmt.AddValue(1, spawnId);
            stmt.AddValue(2, GetId());
            stmt.AddValue(3, GetInstanceId());
            DB.Characters.ExecuteOrAppend(dbTrans, stmt);
        }

        private void DoRespawn(SpawnObjectType type, ulong spawnId, uint gridId)
        {
            if (!IsGridLoaded(gridId)) // if grid isn't loaded, this will be processed in grid load handler
                return;

            switch (type)
            {
                case SpawnObjectType.Creature:
                    {
                        Creature obj = new();

                        if (!obj.LoadFromDB(spawnId, this, true, true))
                            obj.Dispose();

                        break;
                    }
                case SpawnObjectType.GameObject:
                    {
                        GameObject obj = new();

                        if (!obj.LoadFromDB(spawnId, this, true))
                            obj.Dispose();

                        break;
                    }
                default:
                    Cypher.Assert(false, $"Invalid spawn Type {type} (spawnid {spawnId}) on map {GetId()}");

                    break;
            }
        }

        private void ProcessRespawns()
        {
            long now = GameTime.GetGameTime();

            while (!_respawnTimes.Empty())
            {
                RespawnInfo next = _respawnTimes.First();

                if (now < next.RespawnTime) // done for this tick
                    break;

                uint poolId = Global.PoolMgr.IsPartOfAPool(next.Type, next.SpawnId);

                if (poolId != 0) // is this part of a pool?
                {
                    // if yes, respawn will be handled by (external) pooling logic, just delete the respawn Time
                    // step 1: remove entry from maps to avoid it being reachable by outside logic
                    _respawnTimes.Remove(next);
                    GetRespawnMapForType(next.Type).Remove(next.SpawnId);

                    // step 2: tell pooling logic to do its thing
                    Global.PoolMgr.UpdatePool(GetPoolData(), poolId, next.Type, next.SpawnId);

                    // step 3: get rid of the actual entry
                    RemoveRespawnTime(next.Type, next.SpawnId, null, true);
                    GetRespawnMapForType(next.Type).Remove(next.SpawnId);
                }
                else if (CheckRespawn(next)) // see if we're allowed to respawn
                {
                    // ok, respawn
                    // step 1: remove entry from maps to avoid it being reachable by outside logic
                    _respawnTimes.Remove(next);
                    GetRespawnMapForType(next.Type).Remove(next.SpawnId);

                    // step 2: do the respawn, which involves external logic
                    DoRespawn(next.Type, next.SpawnId, next.GridId);

                    // step 3: get rid of the actual entry
                    RemoveRespawnTime(next.Type, next.SpawnId, null, true);
                    GetRespawnMapForType(next.Type).Remove(next.SpawnId);
                }
                else if (next.RespawnTime == 0)
                {
                    // just remove this respawn entry without rescheduling
                    _respawnTimes.Remove(next);
                    GetRespawnMapForType(next.Type).Remove(next.SpawnId);
                    RemoveRespawnTime(next.Type, next.SpawnId, null, true);
                }
                else
                {
                    // new respawn Time, update heap position
                    Cypher.Assert(now < next.RespawnTime); // infinite loop guard
                    SaveRespawnInfoDB(next);
                }
            }
        }

        private bool ShouldBeSpawnedOnGridLoad(SpawnObjectType type, ulong spawnId)
        {
            Cypher.Assert(SpawnMetadata.TypeHasData(type));

            // check if the object is on its respawn timer
            if (GetRespawnTime(type, spawnId) != 0)
                return false;

            SpawnMetadata spawnData = Global.ObjectMgr.GetSpawnMetadata(type, spawnId);
            // check if the object is part of a spawn group
            SpawnGroupTemplateData spawnGroup = spawnData.spawnGroupData;

            if (!spawnGroup.flags.HasFlag(SpawnGroupFlags.System))
                if (!IsSpawnGroupActive(spawnGroup.groupId))
                    return false;

            if (spawnData.ToSpawnData().poolId != 0)
                if (!GetPoolData().IsSpawnedObject(type, spawnId))
                    return false;

            return true;
        }

        private SpawnGroupTemplateData GetSpawnGroupData(uint groupId)
        {
            SpawnGroupTemplateData data = Global.ObjectMgr.GetSpawnGroupData(groupId);

            if (data != null &&
                (data.flags.HasAnyFlag(SpawnGroupFlags.System) || data.mapId == GetId()))
                return data;

            return null;
        }

        private void RemoveAllObjectsInRemoveList()
        {
            while (!i_objectsToSwitch.Empty())
            {
                KeyValuePair<WorldObject, bool> pair = i_objectsToSwitch.First();
                WorldObject obj = pair.Key;
                bool on = pair.Value;
                i_objectsToSwitch.Remove(pair.Key);

                if (!obj.IsPermanentWorldObject())
                    switch (obj.GetTypeId())
                    {
                        case TypeId.Unit:
                            SwitchGridContainers(obj.ToCreature(), on);

                            break;
                        default:
                            break;
                    }
            }

            while (!i_objectsToRemove.Empty())
            {
                WorldObject obj = i_objectsToRemove.First();

                switch (obj.GetTypeId())
                {
                    case TypeId.Corpse:
                        {
                            Corpse corpse = ObjectAccessor.GetCorpse(obj, obj.GetGUID());

                            if (corpse == null)
                                Log.outError(LogFilter.Maps, "Tried to delete corpse/bones {0} that is not in map.", obj.GetGUID().ToString());
                            else
                                RemoveFromMap(corpse, true);

                            break;
                        }
                    case TypeId.DynamicObject:
                        RemoveFromMap(obj, true);

                        break;
                    case TypeId.AreaTrigger:
                        RemoveFromMap(obj, true);

                        break;
                    case TypeId.Conversation:
                        RemoveFromMap(obj, true);

                        break;
                    case TypeId.GameObject:
                        GameObject go = obj.ToGameObject();
                        Transport transport = go.ToTransport();

                        if (transport)
                            RemoveFromMap(transport, true);
                        else
                            RemoveFromMap(go, true);

                        break;
                    case TypeId.Unit:
                        // in case triggered sequence some spell can continue casting after prev CleanupsBeforeDelete call
                        // make sure that like sources Auras/etc removed before destructor start
                        obj.ToCreature().CleanupsBeforeDelete();
                        RemoveFromMap(obj.ToCreature(), true);

                        break;
                    default:
                        Log.outError(LogFilter.Maps, "Non-grid object (TypeId: {0}) is in grid object remove list, ignored.", obj.GetTypeId());

                        break;
                }

                i_objectsToRemove.Remove(obj);
            }
        }

        private void AddToActiveHelper(WorldObject obj)
        {
            _activeNonPlayers.Add(obj);
        }

        private void RemoveFromActiveHelper(WorldObject obj)
        {
            _activeNonPlayers.Remove(obj);
        }

        private void RemoveCorpse(Corpse corpse)
        {
            Cypher.Assert(corpse);

            corpse.UpdateObjectVisibilityOnDestroy();

            if (corpse.GetCurrentCell() != null)
            {
                RemoveFromMap(corpse, false);
            }
            else
            {
                corpse.RemoveFromWorld();
                corpse.ResetMap();
            }

            _corpsesByCell.Remove(corpse.GetCellCoord().GetId(), corpse);

            if (corpse.GetCorpseType() != CorpseType.Bones)
                _corpsesByPlayer.Remove(corpse.GetOwnerGUID());
            else
                _corpseBones.Remove(corpse);
        }

        private void SendZoneWeather(ZoneDynamicInfo zoneDynamicInfo, Player player)
        {
            WeatherState weatherId = zoneDynamicInfo.WeatherId;

            if (weatherId != 0)
            {
                WeatherPkt weather = new(weatherId, zoneDynamicInfo.Intensity);
                player.SendPacket(weather);
            }
            else if (zoneDynamicInfo.DefaultWeather != null)
            {
                zoneDynamicInfo.DefaultWeather.SendWeatherUpdateToPlayer(player);
            }
            else
            {
                Weather.SendFineWeatherUpdateToPlayer(player);
            }
        }

        private bool GetUnloadLock(GridCoord p)
        {
            return GetGrid(p.X_coord, p.Y_coord).GetUnloadLock();
        }

        private void SetUnloadLock(GridCoord p, bool on)
        {
            GetGrid(p.X_coord, p.Y_coord).SetUnloadExplicitLock(on);
        }

        private bool GetEntrancePos(out uint mapid, out float x, out float y)
        {
            mapid = 0;
            x = 0;
            y = 0;

            if (i_mapRecord == null)
                return false;

            return i_mapRecord.GetEntrancePos(out mapid, out x, out y);
        }

        private void ResetMarkedCells()
        {
            marked_cells.SetAll(false);
        }

        private bool IsCellMarked(uint pCellId)
        {
            return marked_cells.Get((int)pCellId);
        }

        private void MarkCell(uint pCellId)
        {
            marked_cells.Set((int)pCellId, true);
        }

        private void SetTimer(uint t)
        {
            i_gridExpiry = t < MapConst.MinGridDelay ? MapConst.MinGridDelay : t;
        }

        private Grid GetGrid(uint x, uint y)
        {
            if (x > MapConst.MaxGrids ||
                y > MapConst.MaxGrids)
                return null;

            return i_grids[x][y];
        }

        private bool IsGridObjectDataLoaded(uint x, uint y)
        {
            return GetGrid(x, y).IsGridObjectDataLoaded();
        }

        private void SetGridObjectDataLoaded(bool pLoaded, uint x, uint y)
        {
            GetGrid(x, y).SetGridObjectDataLoaded(pLoaded);
        }

        private ObjectGuidGenerator GetGuidSequenceGenerator(HighGuid high)
        {
            if (!_guidGenerators.ContainsKey(high))
                _guidGenerators[high] = new ObjectGuidGenerator(high);

            return _guidGenerators[high];
        }

        #region Script Updates

        //MapScript
        public static void OnCreateMap(Map map)
        {
            Cypher.Assert(map != null);
            var record = map.GetEntry();

            if (record != null &&
                record.IsWorldMap())
                Global.ScriptMgr.ForEach<IMapOnCreate<Map>>(p => p.OnCreate(map));

            if (record != null &&
                record.IsDungeon())
                Global.ScriptMgr.ForEach<IMapOnCreate<InstanceMap>>(p => p.OnCreate(map.ToInstanceMap()));

            if (record != null &&
                record.IsBattleground())
                Global.ScriptMgr.ForEach<IMapOnCreate<BattlegroundMap>>(p => p.OnCreate(map.ToBattlegroundMap()));
        }

        public static void OnDestroyMap(Map map)
        {
            Cypher.Assert(map != null);
            var record = map.GetEntry();

            if (record != null &&
                record.IsWorldMap())
                Global.ScriptMgr.ForEach<IMapOnDestroy<Map>>(p => p.OnDestroy(map));

            if (record != null &&
                record.IsDungeon())
                Global.ScriptMgr.ForEach<IMapOnDestroy<InstanceMap>>(p => p.OnDestroy(map.ToInstanceMap()));

            if (record != null &&
                record.IsBattleground())
                Global.ScriptMgr.ForEach<IMapOnDestroy<BattlegroundMap>>(p => p.OnDestroy(map.ToBattlegroundMap()));
        }

        public static void OnPlayerEnterMap(Map map, Player player)
        {
            Cypher.Assert(map != null);
            Cypher.Assert(player != null);

            Global.ScriptMgr.ForEach<IPlayerOnMapChanged>(p => p.OnMapChanged(player));

            var record = map.GetEntry();

            if (record != null &&
                record.IsWorldMap())
                Global.ScriptMgr.ForEach<IMapOnPlayerEnter<Map>>(p => p.OnPlayerEnter(map, player));

            if (record != null &&
                record.IsDungeon())
                Global.ScriptMgr.ForEach<IMapOnPlayerEnter<InstanceMap>>(p => p.OnPlayerEnter(map.ToInstanceMap(), player));

            if (record != null &&
                record.IsBattleground())
                Global.ScriptMgr.ForEach<IMapOnPlayerEnter<BattlegroundMap>>(p => p.OnPlayerEnter(map.ToBattlegroundMap(), player));
        }

        public static void OnPlayerLeaveMap(Map map, Player player)
        {
            Cypher.Assert(map != null);
            var record = map.GetEntry();

            if (record != null &&
                record.IsWorldMap())
                Global.ScriptMgr.ForEach<IMapOnPlayerLeave<Map>>(p => p.OnPlayerLeave(map, player));

            if (record != null &&
                record.IsDungeon())
                Global.ScriptMgr.ForEach<IMapOnPlayerLeave<InstanceMap>>(p => p.OnPlayerLeave(map.ToInstanceMap(), player));

            if (record != null &&
                record.IsBattleground())
                Global.ScriptMgr.ForEach<IMapOnPlayerLeave<BattlegroundMap>>(p => p.OnPlayerLeave(map.ToBattlegroundMap(), player));
        }

        public static void OnMapUpdate(Map map, uint diff)
        {
            Cypher.Assert(map != null);
            var record = map.GetEntry();

            if (record != null &&
                record.IsWorldMap())
                Global.ScriptMgr.ForEach<IMapOnUpdate<Map>>(p => p.OnUpdate(map, diff));

            if (record != null &&
                record.IsDungeon())
                Global.ScriptMgr.ForEach<IMapOnUpdate<InstanceMap>>(p => p.OnUpdate(map.ToInstanceMap(), diff));

            if (record != null &&
                record.IsBattleground())
                Global.ScriptMgr.ForEach<IMapOnUpdate<BattlegroundMap>>(p => p.OnUpdate(map.ToBattlegroundMap(), diff));
        }

        #endregion

        #region Scripts

        // Put scripts in the execution queue
        public void ScriptsStart(ScriptsType scriptsType, uint id, WorldObject source, WorldObject target)
        {
            var scripts = Global.ObjectMgr.GetScriptsMapByType(scriptsType);

            // Find the script map
            MultiMap<uint, ScriptInfo> list = scripts.LookupByKey(id);

            if (list == null)
                return;

            // prepare static _data
            ObjectGuid sourceGUID = source != null ? source.GetGUID() : ObjectGuid.Empty; //some script commands doesn't have source
            ObjectGuid targetGUID = target != null ? target.GetGUID() : ObjectGuid.Empty;
            ObjectGuid ownerGUID = (source != null && source.IsTypeMask(TypeMask.Item)) ? ((Item)source).GetOwnerGUID() : ObjectGuid.Empty;

            // Schedule script execution for all scripts in the script map
            bool immedScript = false;

            foreach (var script in list)
            {
                ScriptAction sa;
                sa.SourceGUID = sourceGUID;
                sa.TargetGUID = targetGUID;
                sa.OwnerGUID = ownerGUID;

                sa.Script = script.Value;
                _scriptSchedule.Add(GameTime.GetGameTime() + script.Key, sa);

                if (script.Key == 0)
                    immedScript = true;

                Global.MapMgr.IncreaseScheduledScriptsCount();
            }

            // If one of the effects should be immediate, launch the script execution
            if (immedScript && !i_scriptLock)
            {
                i_scriptLock = true;
                ScriptsProcess();
                i_scriptLock = false;
            }
        }

        public void ScriptCommandStart(ScriptInfo script, uint delay, WorldObject source, WorldObject target)
        {
            // NOTE: script record _must_ exist until command executed

            // prepare static _data
            ObjectGuid sourceGUID = source != null ? source.GetGUID() : ObjectGuid.Empty;
            ObjectGuid targetGUID = target != null ? target.GetGUID() : ObjectGuid.Empty;
            ObjectGuid ownerGUID = (source != null && source.IsTypeMask(TypeMask.Item)) ? ((Item)source).GetOwnerGUID() : ObjectGuid.Empty;

            var sa = new ScriptAction();
            sa.SourceGUID = sourceGUID;
            sa.TargetGUID = targetGUID;
            sa.OwnerGUID = ownerGUID;

            sa.Script = script;
            _scriptSchedule.Add(GameTime.GetGameTime() + delay, sa);

            Global.MapMgr.IncreaseScheduledScriptsCount();

            // If effects should be immediate, launch the script execution
            if (delay == 0 &&
                !i_scriptLock)
            {
                i_scriptLock = true;
                ScriptsProcess();
                i_scriptLock = false;
            }
        }

        // Helpers for ScriptProcess method.
        private Player _GetScriptPlayerSourceOrTarget(WorldObject source, WorldObject target, ScriptInfo scriptInfo)
        {
            Player player = null;

            if (source == null &&
                target == null)
            {
                Log.outError(LogFilter.Scripts, "{0} source and Target objects are NULL.", scriptInfo.GetDebugInfo());
            }
            else
            {
                // Check Target first, then source.
                if (target != null)
                    player = target.ToPlayer();

                if (player == null &&
                    source != null)
                    player = source.ToPlayer();

                if (player == null)
                    Log.outError(LogFilter.Scripts,
                                 "{0} neither source nor Target object is player (source: TypeId: {1}, Entry: {2}, {3}; Target: TypeId: {4}, Entry: {5}, {6}), skipping.",
                                 scriptInfo.GetDebugInfo(),
                                 source ? source.GetTypeId() : 0,
                                 source ? source.GetEntry() : 0,
                                 source ? source.GetGUID().ToString() : "",
                                 target ? target.GetTypeId() : 0,
                                 target ? target.GetEntry() : 0,
                                 target ? target.GetGUID().ToString() : "");
            }

            return player;
        }

        private Creature _GetScriptCreatureSourceOrTarget(WorldObject source, WorldObject target, ScriptInfo scriptInfo, bool bReverse = false)
        {
            Creature creature = null;

            if (source == null &&
                target == null)
            {
                Log.outError(LogFilter.Scripts, "{0} source and Target objects are NULL.", scriptInfo.GetDebugInfo());
            }
            else
            {
                if (bReverse)
                {
                    // Check Target first, then source.
                    if (target != null)
                        creature = target.ToCreature();

                    if (creature == null &&
                        source != null)
                        creature = source.ToCreature();
                }
                else
                {
                    // Check source first, then Target.
                    if (source != null)
                        creature = source.ToCreature();

                    if (creature == null &&
                        target != null)
                        creature = target.ToCreature();
                }

                if (creature == null)
                    Log.outError(LogFilter.Scripts,
                                 "{0} neither source nor Target are creatures (source: TypeId: {1}, Entry: {2}, {3}; Target: TypeId: {4}, Entry: {5}, {6}), skipping.",
                                 scriptInfo.GetDebugInfo(),
                                 source ? source.GetTypeId() : 0,
                                 source ? source.GetEntry() : 0,
                                 source ? source.GetGUID().ToString() : "",
                                 target ? target.GetTypeId() : 0,
                                 target ? target.GetEntry() : 0,
                                 target ? target.GetGUID().ToString() : "");
            }

            return creature;
        }

        private GameObject _GetScriptGameObjectSourceOrTarget(WorldObject source, WorldObject target, ScriptInfo scriptInfo, bool bReverse)
        {
            GameObject gameobject = null;

            if (source == null &&
                target == null)
            {
                Log.outError(LogFilter.MapsScript, $"{scriptInfo.GetDebugInfo()} source and Target objects are NULL.");
            }
            else
            {
                if (bReverse)
                {
                    // Check Target first, then source.
                    if (target != null)
                        gameobject = target.ToGameObject();

                    if (gameobject == null &&
                        source != null)
                        gameobject = source.ToGameObject();
                }
                else
                {
                    // Check source first, then Target.
                    if (source != null)
                        gameobject = source.ToGameObject();

                    if (gameobject == null &&
                        target != null)
                        gameobject = target.ToGameObject();
                }

                if (gameobject == null)
                    Log.outError(LogFilter.MapsScript,
                                 $"{scriptInfo.GetDebugInfo()} neither source nor Target are gameobjects " +
                                 $"(source: TypeId: {(source != null ? source.GetTypeId() : 0)}, Entry: {(source != null ? source.GetEntry() : 0)}, {(source != null ? source.GetGUID() : ObjectGuid.Empty)}; " +
                                 $"Target: TypeId: {(target != null ? target.GetTypeId() : 0)}, Entry: {(target != null ? target.GetEntry() : 0)}, {(target != null ? target.GetGUID() : ObjectGuid.Empty)}), skipping.");
            }

            return gameobject;
        }

        private Unit _GetScriptUnit(WorldObject obj, bool isSource, ScriptInfo scriptInfo)
        {
            Unit unit = null;

            if (obj == null)
            {
                Log.outError(LogFilter.Scripts,
                             "{0} {1} object is NULL.",
                             scriptInfo.GetDebugInfo(),
                             isSource ? "source" : "Target");
            }
            else if (!obj.IsTypeMask(TypeMask.Unit))
            {
                Log.outError(LogFilter.Scripts,
                             "{0} {1} object is not unit (TypeId: {2}, Entry: {3}, GUID: {4}), skipping.",
                             scriptInfo.GetDebugInfo(),
                             isSource ? "source" : "Target",
                             obj.GetTypeId(),
                             obj.GetEntry(),
                             obj.GetGUID().ToString());
            }
            else
            {
                unit = obj.ToUnit();

                if (unit == null)
                    Log.outError(LogFilter.Scripts, "{0} {1} object could not be casted to unit.", scriptInfo.GetDebugInfo(), isSource ? "source" : "Target");
            }

            return unit;
        }

        private Player _GetScriptPlayer(WorldObject obj, bool isSource, ScriptInfo scriptInfo)
        {
            Player player = null;

            if (obj == null)
            {
                Log.outError(LogFilter.Scripts,
                             "{0} {1} object is NULL.",
                             scriptInfo.GetDebugInfo(),
                             isSource ? "source" : "Target");
            }
            else
            {
                player = obj.ToPlayer();

                if (player == null)
                    Log.outError(LogFilter.Scripts,
                                 "{0} {1} object is not a player (TypeId: {2}, Entry: {3}, GUID: {4}).",
                                 scriptInfo.GetDebugInfo(),
                                 isSource ? "source" : "Target",
                                 obj.GetTypeId(),
                                 obj.GetEntry(),
                                 obj.GetGUID().ToString());
            }

            return player;
        }

        private Creature _GetScriptCreature(WorldObject obj, bool isSource, ScriptInfo scriptInfo)
        {
            Creature creature = null;

            if (obj == null)
            {
                Log.outError(LogFilter.Scripts, "{0} {1} object is NULL.", scriptInfo.GetDebugInfo(), isSource ? "source" : "Target");
            }
            else
            {
                creature = obj.ToCreature();

                if (creature == null)
                    Log.outError(LogFilter.Scripts,
                                 "{0} {1} object is not a creature (TypeId: {2}, Entry: {3}, GUID: {4}).",
                                 scriptInfo.GetDebugInfo(),
                                 isSource ? "source" : "Target",
                                 obj.GetTypeId(),
                                 obj.GetEntry(),
                                 obj.GetGUID().ToString());
            }

            return creature;
        }

        private WorldObject _GetScriptWorldObject(WorldObject obj, bool isSource, ScriptInfo scriptInfo)
        {
            WorldObject pWorldObject = null;

            if (obj == null)
            {
                Log.outError(LogFilter.Scripts, "{0} {1} object is NULL.", scriptInfo.GetDebugInfo(), isSource ? "source" : "Target");
            }
            else
            {
                pWorldObject = obj;

                if (pWorldObject == null)
                    Log.outError(LogFilter.Scripts,
                                 "{0} {1} object is not a world object (TypeId: {2}, Entry: {3}, GUID: {4}).",
                                 scriptInfo.GetDebugInfo(),
                                 isSource ? "source" : "Target",
                                 obj.GetTypeId(),
                                 obj.GetEntry(),
                                 obj.GetGUID().ToString());
            }

            return pWorldObject;
        }

        private void _ScriptProcessDoor(WorldObject source, WorldObject target, ScriptInfo scriptInfo)
        {
            bool bOpen = false;
            ulong guid = scriptInfo.ToggleDoor.GOGuid;
            int nTimeToToggle = Math.Max(15, (int)scriptInfo.ToggleDoor.ResetDelay);

            switch (scriptInfo.command)
            {
                case ScriptCommands.OpenDoor:
                    bOpen = true;

                    break;
                case ScriptCommands.CloseDoor:
                    break;
                default:
                    Log.outError(LogFilter.Scripts, "{0} unknown command for _ScriptProcessDoor.", scriptInfo.GetDebugInfo());

                    return;
            }

            if (guid == 0)
            {
                Log.outError(LogFilter.Scripts, "{0} door Guid is not specified.", scriptInfo.GetDebugInfo());
            }
            else if (source == null)
            {
                Log.outError(LogFilter.Scripts, "{0} source object is NULL.", scriptInfo.GetDebugInfo());
            }
            else if (!source.IsTypeMask(TypeMask.Unit))
            {
                Log.outError(LogFilter.Scripts,
                             "{0} source object is not unit (TypeId: {1}, Entry: {2}, GUID: {3}), skipping.",
                             scriptInfo.GetDebugInfo(),
                             source.GetTypeId(),
                             source.GetEntry(),
                             source.GetGUID().ToString());
            }
            else
            {
                if (source == null)
                {
                    Log.outError(LogFilter.Scripts,
                                 "{0} source object could not be casted to world object (TypeId: {1}, Entry: {2}, GUID: {3}), skipping.",
                                 scriptInfo.GetDebugInfo(),
                                 source.GetTypeId(),
                                 source.GetEntry(),
                                 source.GetGUID().ToString());
                }
                else
                {
                    GameObject pDoor = _FindGameObject(source, guid);

                    if (pDoor == null)
                    {
                        Log.outError(LogFilter.Scripts, "{0} gameobject was not found (Guid: {1}).", scriptInfo.GetDebugInfo(), guid);
                    }
                    else if (pDoor.GetGoType() != GameObjectTypes.Door)
                    {
                        Log.outError(LogFilter.Scripts, "{0} gameobject is not a door (GoType: {1}, Entry: {2}, GUID: {3}).", scriptInfo.GetDebugInfo(), pDoor.GetGoType(), pDoor.GetEntry(), pDoor.GetGUID().ToString());
                    }
                    else if (bOpen == (pDoor.GetGoState() == GameObjectState.Ready))
                    {
                        pDoor.UseDoorOrButton((uint)nTimeToToggle);

                        if (target != null &&
                            target.IsTypeMask(TypeMask.GameObject))
                        {
                            GameObject goTarget = target.ToGameObject();

                            if (goTarget != null &&
                                goTarget.GetGoType() == GameObjectTypes.Button)
                                goTarget.UseDoorOrButton((uint)nTimeToToggle);
                        }
                    }
                }
            }
        }

        private GameObject _FindGameObject(WorldObject searchObject, ulong guid)
        {
            var bounds = searchObject.GetMap().GetGameObjectBySpawnIdStore().LookupByKey(guid);

            if (bounds.Empty())
                return null;

            return bounds[0];
        }

        // Process queued scripts
        private void ScriptsProcess()
        {
            if (_scriptSchedule.Empty())
                return;

            // Process overdue queued scripts
            KeyValuePair<long, ScriptAction> iter = _scriptSchedule.First();

            while (!_scriptSchedule.Empty() && (iter.Key <= GameTime.GetGameTime()))
            {
                ScriptAction step = iter.Value;

                WorldObject source = null;

                if (!step.SourceGUID.IsEmpty())
                    switch (step.SourceGUID.GetHigh())
                    {
                        case HighGuid.Item: // as well as HIGHGUID_CONTAINER
                            Player player = GetPlayer(step.OwnerGUID);

                            if (player != null)
                                source = player.GetItemByGuid(step.SourceGUID);

                            break;
                        case HighGuid.Creature:
                        case HighGuid.Vehicle:
                            source = GetCreature(step.SourceGUID);

                            break;
                        case HighGuid.Pet:
                            source = GetPet(step.SourceGUID);

                            break;
                        case HighGuid.Player:
                            source = GetPlayer(step.SourceGUID);

                            break;
                        case HighGuid.GameObject:
                        case HighGuid.Transport:
                            source = GetGameObject(step.SourceGUID);

                            break;
                        case HighGuid.Corpse:
                            source = GetCorpse(step.SourceGUID);

                            break;
                        default:
                            Log.outError(LogFilter.Scripts,
                                         "{0} source with unsupported high Guid (GUID: {1}, high Guid: {2}).",
                                         step.Script.GetDebugInfo(),
                                         step.SourceGUID,
                                         step.SourceGUID.ToString());

                            break;
                    }

                WorldObject target = null;

                if (!step.TargetGUID.IsEmpty())
                    switch (step.TargetGUID.GetHigh())
                    {
                        case HighGuid.Creature:
                        case HighGuid.Vehicle:
                            target = GetCreature(step.TargetGUID);

                            break;
                        case HighGuid.Pet:
                            target = GetPet(step.TargetGUID);

                            break;
                        case HighGuid.Player:
                            target = GetPlayer(step.TargetGUID);

                            break;
                        case HighGuid.GameObject:
                        case HighGuid.Transport:
                            target = GetGameObject(step.TargetGUID);

                            break;
                        case HighGuid.Corpse:
                            target = GetCorpse(step.TargetGUID);

                            break;
                        default:
                            Log.outError(LogFilter.Scripts, "{0} Target with unsupported high Guid {1}.", step.Script.GetDebugInfo(), step.TargetGUID.ToString());

                            break;
                    }

                switch (step.Script.command)
                {
                    case ScriptCommands.Talk:
                        {
                            if (step.Script.Talk.ChatType > ChatMsg.Whisper &&
                                step.Script.Talk.ChatType != ChatMsg.RaidBossWhisper)
                            {
                                Log.outError(LogFilter.Scripts,
                                             "{0} invalid chat Type ({1}) specified, skipping.",
                                             step.Script.GetDebugInfo(),
                                             step.Script.Talk.ChatType);

                                break;
                            }

                            if (step.Script.Talk.Flags.HasAnyFlag(eScriptFlags.TalkUsePlayer))
                                source = _GetScriptPlayerSourceOrTarget(source, target, step.Script);
                            else
                                source = _GetScriptCreatureSourceOrTarget(source, target, step.Script);

                            if (source)
                            {
                                Unit sourceUnit = source.ToUnit();

                                if (!sourceUnit)
                                {
                                    Log.outError(LogFilter.Scripts, "{0} source object ({1}) is not an unit, skipping.", step.Script.GetDebugInfo(), source.GetGUID().ToString());

                                    break;
                                }

                                switch (step.Script.Talk.ChatType)
                                {
                                    case ChatMsg.Say:
                                        sourceUnit.Say((uint)step.Script.Talk.TextID, target);

                                        break;
                                    case ChatMsg.Yell:
                                        sourceUnit.Yell((uint)step.Script.Talk.TextID, target);

                                        break;
                                    case ChatMsg.Emote:
                                    case ChatMsg.RaidBossEmote:
                                        sourceUnit.TextEmote((uint)step.Script.Talk.TextID, target, step.Script.Talk.ChatType == ChatMsg.RaidBossEmote);

                                        break;
                                    case ChatMsg.Whisper:
                                    case ChatMsg.RaidBossWhisper:
                                        {
                                            Player receiver = target ? target.ToPlayer() : null;

                                            if (!receiver)
                                                Log.outError(LogFilter.Scripts, "{0} attempt to whisper to non-player unit, skipping.", step.Script.GetDebugInfo());
                                            else
                                                sourceUnit.Whisper((uint)step.Script.Talk.TextID, receiver, step.Script.Talk.ChatType == ChatMsg.RaidBossWhisper);

                                            break;
                                        }
                                    default:
                                        break; // must be already checked at load
                                }
                            }

                            break;
                        }
                    case ScriptCommands.Emote:
                        {
                            // Source or Target must be Creature.
                            Creature cSource = _GetScriptCreatureSourceOrTarget(source, target, step.Script);

                            if (cSource)
                            {
                                if (step.Script.Emote.Flags.HasAnyFlag(eScriptFlags.EmoteUseState))
                                    cSource.SetEmoteState((Emote)step.Script.Emote.EmoteID);
                                else
                                    cSource.HandleEmoteCommand((Emote)step.Script.Emote.EmoteID);
                            }

                            break;
                        }
                    case ScriptCommands.MoveTo:
                        {
                            // Source or Target must be Creature.
                            Creature cSource = _GetScriptCreatureSourceOrTarget(source, target, step.Script);

                            if (cSource)
                            {
                                Unit unit = cSource.ToUnit();

                                if (step.Script.MoveTo.TravelTime != 0)
                                {
                                    float speed =
                                        unit.GetDistance(step.Script.MoveTo.DestX,
                                                         step.Script.MoveTo.DestY,
                                                         step.Script.MoveTo.DestZ) /
                                        (step.Script.MoveTo.TravelTime * 0.001f);

                                    unit.MonsterMoveWithSpeed(step.Script.MoveTo.DestX,
                                                              step.Script.MoveTo.DestY,
                                                              step.Script.MoveTo.DestZ,
                                                              speed);
                                }
                                else
                                {
                                    unit.NearTeleportTo(step.Script.MoveTo.DestX,
                                                        step.Script.MoveTo.DestY,
                                                        step.Script.MoveTo.DestZ,
                                                        unit.GetOrientation());
                                }
                            }

                            break;
                        }
                    case ScriptCommands.TeleportTo:
                        {
                            if (step.Script.TeleportTo.Flags.HasAnyFlag(eScriptFlags.TeleportUseCreature))
                            {
                                // Source or Target must be Creature.
                                Creature cSource = _GetScriptCreatureSourceOrTarget(source, target, step.Script);

                                if (cSource)
                                    cSource.NearTeleportTo(step.Script.TeleportTo.DestX,
                                                           step.Script.TeleportTo.DestY,
                                                           step.Script.TeleportTo.DestZ,
                                                           step.Script.TeleportTo.Orientation);
                            }
                            else
                            {
                                // Source or Target must be Player.
                                Player player = _GetScriptPlayerSourceOrTarget(source, target, step.Script);

                                if (player)
                                    player.TeleportTo(step.Script.TeleportTo.MapID,
                                                      step.Script.TeleportTo.DestX,
                                                      step.Script.TeleportTo.DestY,
                                                      step.Script.TeleportTo.DestZ,
                                                      step.Script.TeleportTo.Orientation);
                            }

                            break;
                        }
                    case ScriptCommands.QuestExplored:
                        {
                            if (!source)
                            {
                                Log.outError(LogFilter.Scripts, "{0} source object is NULL.", step.Script.GetDebugInfo());

                                break;
                            }

                            if (!target)
                            {
                                Log.outError(LogFilter.Scripts, "{0} Target object is NULL.", step.Script.GetDebugInfo());

                                break;
                            }

                            // when script called for Item spell casting then Target == (unit or GO) and source is player
                            WorldObject worldObject;
                            Player player = target.ToPlayer();

                            if (player != null)
                            {
                                if (!source.IsTypeId(TypeId.Unit) &&
                                    !source.IsTypeId(TypeId.GameObject) &&
                                    !source.IsTypeId(TypeId.Player))
                                {
                                    Log.outError(LogFilter.Scripts,
                                                 "{0} source is not unit, gameobject or player (TypeId: {1}, Entry: {2}, GUID: {3}), skipping.",
                                                 step.Script.GetDebugInfo(),
                                                 source.GetTypeId(),
                                                 source.GetEntry(),
                                                 source.GetGUID().ToString());

                                    break;
                                }

                                worldObject = source;
                            }
                            else
                            {
                                player = source.ToPlayer();

                                if (player != null)
                                {
                                    if (!target.IsTypeId(TypeId.Unit) &&
                                        !target.IsTypeId(TypeId.GameObject) &&
                                        !target.IsTypeId(TypeId.Player))
                                    {
                                        Log.outError(LogFilter.Scripts,
                                                     "{0} Target is not unit, gameobject or player (TypeId: {1}, Entry: {2}, GUID: {3}), skipping.",
                                                     step.Script.GetDebugInfo(),
                                                     target.GetTypeId(),
                                                     target.GetEntry(),
                                                     target.GetGUID().ToString());

                                        break;
                                    }

                                    worldObject = target;
                                }
                                else
                                {
                                    Log.outError(LogFilter.Scripts,
                                                 "{0} neither source nor Target is player (Entry: {0}, GUID: {1}; Target: Entry: {2}, GUID: {3}), skipping.",
                                                 step.Script.GetDebugInfo(),
                                                 source.GetEntry(),
                                                 source.GetGUID().ToString(),
                                                 target.GetEntry(),
                                                 target.GetGUID().ToString());

                                    break;
                                }
                            }

                            // quest Id and Flags checked at script loading
                            if ((!worldObject.IsTypeId(TypeId.Unit) || worldObject.ToUnit().IsAlive()) &&
                                (step.Script.QuestExplored.Distance == 0 ||
                                 worldObject.IsWithinDistInMap(player, step.Script.QuestExplored.Distance)))
                                player.AreaExploredOrEventHappens(step.Script.QuestExplored.QuestID);
                            else
                                player.FailQuest(step.Script.QuestExplored.QuestID);

                            break;
                        }

                    case ScriptCommands.KillCredit:
                        {
                            // Source or Target must be Player.
                            Player player = _GetScriptPlayerSourceOrTarget(source, target, step.Script);

                            if (player)
                            {
                                if (step.Script.KillCredit.Flags.HasAnyFlag(eScriptFlags.KillcreditRewardGroup))
                                    player.RewardPlayerAndGroupAtEvent(step.Script.KillCredit.CreatureEntry, player);
                                else
                                    player.KilledMonsterCredit(step.Script.KillCredit.CreatureEntry, ObjectGuid.Empty);
                            }

                            break;
                        }
                    case ScriptCommands.RespawnGameobject:
                        {
                            if (step.Script.RespawnGameObject.GOGuid == 0)
                            {
                                Log.outError(LogFilter.Scripts, "{0} gameobject Guid (datalong) is not specified.", step.Script.GetDebugInfo());

                                break;
                            }

                            // Source or Target must be WorldObject.
                            WorldObject pSummoner = _GetScriptWorldObject(source, true, step.Script);

                            if (pSummoner)
                            {
                                GameObject pGO = _FindGameObject(pSummoner, step.Script.RespawnGameObject.GOGuid);

                                if (pGO == null)
                                {
                                    Log.outError(LogFilter.Scripts, "{0} gameobject was not found (Guid: {1}).", step.Script.GetDebugInfo(), step.Script.RespawnGameObject.GOGuid);

                                    break;
                                }

                                if (pGO.GetGoType() == GameObjectTypes.FishingNode ||
                                    pGO.GetGoType() == GameObjectTypes.Door ||
                                    pGO.GetGoType() == GameObjectTypes.Button ||
                                    pGO.GetGoType() == GameObjectTypes.Trap)
                                {
                                    Log.outError(LogFilter.Scripts,
                                                 "{0} can not be used with gameobject of Type {1} (Guid: {2}).",
                                                 step.Script.GetDebugInfo(),
                                                 pGO.GetGoType(),
                                                 step.Script.RespawnGameObject.GOGuid);

                                    break;
                                }

                                // Check that GO is not spawned
                                if (!pGO.IsSpawned())
                                {
                                    int nTimeToDespawn = Math.Max(5, (int)step.Script.RespawnGameObject.DespawnDelay);
                                    pGO.SetLootState(LootState.Ready);
                                    pGO.SetRespawnTime(nTimeToDespawn);

                                    pGO.GetMap().AddToMap(pGO);
                                }
                            }

                            break;
                        }
                    case ScriptCommands.TempSummonCreature:
                        {
                            // Source must be WorldObject.
                            WorldObject pSummoner = _GetScriptWorldObject(source, true, step.Script);

                            if (pSummoner)
                            {
                                if (step.Script.TempSummonCreature.CreatureEntry == 0)
                                {
                                    Log.outError(LogFilter.Scripts, "{0} creature entry (datalong) is not specified.", step.Script.GetDebugInfo());
                                }
                                else
                                {
                                    float x = step.Script.TempSummonCreature.PosX;
                                    float y = step.Script.TempSummonCreature.PosY;
                                    float z = step.Script.TempSummonCreature.PosZ;
                                    float o = step.Script.TempSummonCreature.Orientation;

                                    if (pSummoner.SummonCreature(step.Script.TempSummonCreature.CreatureEntry, x, y, z, o, TempSummonType.TimedOrDeadDespawn, TimeSpan.FromMilliseconds(step.Script.TempSummonCreature.DespawnDelay)) == null)
                                        Log.outError(LogFilter.Scripts, "{0} creature was not spawned (entry: {1}).", step.Script.GetDebugInfo(), step.Script.TempSummonCreature.CreatureEntry);
                                }
                            }

                            break;
                        }

                    case ScriptCommands.OpenDoor:
                    case ScriptCommands.CloseDoor:
                        _ScriptProcessDoor(source, target, step.Script);

                        break;
                    case ScriptCommands.ActivateObject:
                        {
                            // Source must be Unit.
                            Unit unit = _GetScriptUnit(source, true, step.Script);

                            if (unit)
                            {
                                // Target must be GameObject.
                                if (target == null)
                                {
                                    Log.outError(LogFilter.Scripts, "{0} Target object is NULL.", step.Script.GetDebugInfo());

                                    break;
                                }

                                if (!target.IsTypeId(TypeId.GameObject))
                                {
                                    Log.outError(LogFilter.Scripts,
                                                 "{0} Target object is not gameobject (TypeId: {1}, Entry: {2}, GUID: {3}), skipping.",
                                                 step.Script.GetDebugInfo(),
                                                 target.GetTypeId(),
                                                 target.GetEntry(),
                                                 target.GetGUID().ToString());

                                    break;
                                }

                                GameObject pGO = target.ToGameObject();

                                if (pGO)
                                    pGO.Use(unit);
                            }

                            break;
                        }
                    case ScriptCommands.RemoveAura:
                        {
                            // Source (datalong2 != 0) or Target (datalong2 == 0) must be Unit.
                            bool bReverse = step.Script.RemoveAura.Flags.HasAnyFlag(eScriptFlags.RemoveauraReverse);
                            Unit unit = _GetScriptUnit(bReverse ? source : target, bReverse, step.Script);

                            if (unit)
                                unit.RemoveAurasDueToSpell(step.Script.RemoveAura.SpellID);

                            break;
                        }
                    case ScriptCommands.CastSpell:
                        {
                            if (source == null &&
                                target == null)
                            {
                                Log.outError(LogFilter.Scripts, "{0} source and Target objects are NULL.", step.Script.GetDebugInfo());

                                break;
                            }

                            WorldObject uSource = null;
                            WorldObject uTarget = null;

                            // source/Target cast spell at Target/source (script.datalong2: 0: s.t 1: s.s 2: t.t 3: t.s
                            switch (step.Script.CastSpell.Flags)
                            {
                                case eScriptFlags.CastspellSourceToTarget: // source . Target
                                    uSource = source;
                                    uTarget = target;

                                    break;
                                case eScriptFlags.CastspellSourceToSource: // source . source
                                    uSource = source;
                                    uTarget = uSource;

                                    break;
                                case eScriptFlags.CastspellTargetToTarget: // Target . Target
                                    uSource = target;
                                    uTarget = uSource;

                                    break;
                                case eScriptFlags.CastspellTargetToSource: // Target . source
                                    uSource = target;
                                    uTarget = source;

                                    break;
                                case eScriptFlags.CastspellSearchCreature: // source . creature with entry
                                    uSource = source;
                                    uTarget = uSource?.FindNearestCreature((uint)Math.Abs(step.Script.CastSpell.CreatureEntry), step.Script.CastSpell.SearchRadius);

                                    break;
                            }

                            if (uSource == null)
                            {
                                Log.outError(LogFilter.Scripts, "{0} no source worldobject found for spell {1}", step.Script.GetDebugInfo(), step.Script.CastSpell.SpellID);

                                break;
                            }

                            if (uTarget == null)
                            {
                                Log.outError(LogFilter.Scripts, "{0} no Target worldobject found for spell {1}", step.Script.GetDebugInfo(), step.Script.CastSpell.SpellID);

                                break;
                            }

                            bool triggered = ((int)step.Script.CastSpell.Flags != 4)
                                                 ? step.Script.CastSpell.CreatureEntry.HasAnyFlag((int)eScriptFlags.CastspellTriggered)
                                                 : step.Script.CastSpell.CreatureEntry < 0;

                            uSource.CastSpell(uTarget, step.Script.CastSpell.SpellID, triggered);

                            break;
                        }

                    case ScriptCommands.PlaySound:
                        // Source must be WorldObject.
                        WorldObject obj = _GetScriptWorldObject(source, true, step.Script);

                        if (obj)
                        {
                            // PlaySound.Flags bitmask: 0/1=anyone/Target
                            Player player2 = null;

                            if (step.Script.PlaySound.Flags.HasAnyFlag(eScriptFlags.PlaysoundTargetPlayer))
                            {
                                // Target must be Player.
                                player2 = _GetScriptPlayer(target, false, step.Script);

                                if (target == null)
                                    break;
                            }

                            // PlaySound.Flags bitmask: 0/2=without/with distance dependent
                            if (step.Script.PlaySound.Flags.HasAnyFlag(eScriptFlags.PlaysoundDistanceSound))
                                obj.PlayDistanceSound(step.Script.PlaySound.SoundID, player2);
                            else
                                obj.PlayDirectSound(step.Script.PlaySound.SoundID, player2);
                        }

                        break;

                    case ScriptCommands.CreateItem:
                        // Target or source must be Player.
                        Player pReceiver = _GetScriptPlayerSourceOrTarget(source, target, step.Script);

                        if (pReceiver)
                        {
                            var dest = new List<ItemPosCount>();
                            InventoryResult msg = pReceiver.CanStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, step.Script.CreateItem.ItemEntry, step.Script.CreateItem.Amount);

                            if (msg == InventoryResult.Ok)
                            {
                                Item item = pReceiver.StoreNewItem(dest, step.Script.CreateItem.ItemEntry, true);

                                if (item != null)
                                    pReceiver.SendNewItem(item, step.Script.CreateItem.Amount, false, true);
                            }
                            else
                            {
                                pReceiver.SendEquipError(msg, null, null, step.Script.CreateItem.ItemEntry);
                            }
                        }

                        break;

                    case ScriptCommands.DespawnSelf:
                        {
                            // First try with Target or source creature, then with Target or source gameobject
                            Creature cSource = _GetScriptCreatureSourceOrTarget(source, target, step.Script, true);

                            if (cSource != null)
                            {
                                cSource.DespawnOrUnsummon(TimeSpan.FromMilliseconds(step.Script.DespawnSelf.DespawnDelay));
                            }
                            else
                            {
                                GameObject goSource = _GetScriptGameObjectSourceOrTarget(source, target, step.Script, true);

                                goSource?.DespawnOrUnsummon(TimeSpan.FromMilliseconds(step.Script.DespawnSelf.DespawnDelay));
                            }

                            break;
                        }
                    case ScriptCommands.LoadPath:
                        {
                            // Source must be Unit.
                            Unit unit = _GetScriptUnit(source, true, step.Script);

                            if (unit)
                            {
                                if (Global.WaypointMgr.GetPath(step.Script.LoadPath.PathID) == null)
                                    Log.outError(LogFilter.Scripts, "{0} source object has an invalid path ({1}), skipping.", step.Script.GetDebugInfo(), step.Script.LoadPath.PathID);
                                else
                                    unit.GetMotionMaster().MovePath(step.Script.LoadPath.PathID, step.Script.LoadPath.IsRepeatable != 0);
                            }

                            break;
                        }
                    case ScriptCommands.CallscriptToUnit:
                        {
                            if (step.Script.CallScript.CreatureEntry == 0)
                            {
                                Log.outError(LogFilter.Scripts, "{0} creature entry is not specified, skipping.", step.Script.GetDebugInfo());

                                break;
                            }

                            if (step.Script.CallScript.ScriptID == 0)
                            {
                                Log.outError(LogFilter.Scripts, "{0} script Id is not specified, skipping.", step.Script.GetDebugInfo());

                                break;
                            }

                            Creature cTarget = null;
                            var creatureBounds = _creatureBySpawnIdStore.LookupByKey(step.Script.CallScript.CreatureEntry);

                            if (!creatureBounds.Empty())
                            {
                                // Prefer alive (last respawned) creature
                                var foundCreature = creatureBounds.Find(creature => creature.IsAlive());

                                cTarget = foundCreature ?? creatureBounds[0];
                            }

                            if (cTarget == null)
                            {
                                Log.outError(LogFilter.Scripts, "{0} Target was not found (entry: {1})", step.Script.GetDebugInfo(), step.Script.CallScript.CreatureEntry);

                                break;
                            }

                            // Insert script into schedule but do not start it
                            ScriptsStart((ScriptsType)step.Script.CallScript.ScriptType, step.Script.CallScript.ScriptID, cTarget, null);

                            break;
                        }

                    case ScriptCommands.Kill:
                        {
                            // Source or Target must be Creature.
                            Creature cSource = _GetScriptCreatureSourceOrTarget(source, target, step.Script);

                            if (cSource)
                            {
                                if (cSource.IsDead())
                                {
                                    Log.outError(LogFilter.Scripts, "{0} creature is already dead (Entry: {1}, GUID: {2})", step.Script.GetDebugInfo(), cSource.GetEntry(), cSource.GetGUID().ToString());
                                }
                                else
                                {
                                    cSource.SetDeathState(DeathState.JustDied);

                                    if (step.Script.Kill.RemoveCorpse == 1)
                                        cSource.RemoveCorpse();
                                }
                            }

                            break;
                        }
                    case ScriptCommands.Orientation:
                        {
                            // Source must be Unit.
                            Unit sourceUnit = _GetScriptUnit(source, true, step.Script);

                            if (sourceUnit)
                            {
                                if (step.Script.Orientation.Flags.HasAnyFlag(eScriptFlags.OrientationFaceTarget))
                                {
                                    // Target must be Unit.
                                    Unit targetUnit = _GetScriptUnit(target, false, step.Script);

                                    if (targetUnit == null)
                                        break;

                                    sourceUnit.SetFacingToObject(targetUnit);
                                }
                                else
                                {
                                    sourceUnit.SetFacingTo(step.Script.Orientation._Orientation);
                                }
                            }

                            break;
                        }
                    case ScriptCommands.Equip:
                        {
                            // Source must be Creature.
                            Creature cSource = _GetScriptCreature(source, target, step.Script);

                            if (cSource)
                                cSource.LoadEquipment((int)step.Script.Equip.EquipmentID);

                            break;
                        }
                    case ScriptCommands.Model:
                        {
                            // Source must be Creature.
                            Creature cSource = _GetScriptCreature(source, target, step.Script);

                            if (cSource)
                                cSource.SetDisplayId(step.Script.Model.ModelID);

                            break;
                        }
                    case ScriptCommands.CloseGossip:
                        {
                            // Source must be Player.
                            Player player = _GetScriptPlayer(source, true, step.Script);

                            player?.PlayerTalkClass.SendCloseGossip();

                            break;
                        }
                    case ScriptCommands.Playmovie:
                        {
                            // Source must be Player.
                            Player player = _GetScriptPlayer(source, true, step.Script);

                            if (player)
                                player.SendMovieStart(step.Script.PlayMovie.MovieID);

                            break;
                        }
                    case ScriptCommands.Movement:
                        {
                            // Source must be Creature.
                            Creature cSource = _GetScriptCreature(source, true, step.Script);

                            if (cSource)
                            {
                                if (!cSource.IsAlive())
                                    return;

                                cSource.GetMotionMaster().MoveIdle();

                                switch ((MovementGeneratorType)step.Script.Movement.MovementType)
                                {
                                    case MovementGeneratorType.Random:
                                        cSource.GetMotionMaster().MoveRandom(step.Script.Movement.MovementDistance);

                                        break;
                                    case MovementGeneratorType.Waypoint:
                                        cSource.GetMotionMaster().MovePath((uint)step.Script.Movement.Path, false);

                                        break;
                                }
                            }

                            break;
                        }
                    case ScriptCommands.PlayAnimkit:
                        {
                            // Source must be Creature.
                            Creature cSource = _GetScriptCreature(source, true, step.Script);

                            if (cSource)
                                cSource.PlayOneShotAnimKitId((ushort)step.Script.PlayAnimKit.AnimKitID);

                            break;
                        }
                    default:
                        Log.outError(LogFilter.Scripts, "Unknown script command {0}.", step.Script.GetDebugInfo());

                        break;
                }

                _scriptSchedule.Remove(iter);
                iter = _scriptSchedule.FirstOrDefault();
                Global.MapMgr.DecreaseScheduledScriptCount();
            }
        }

        #endregion

        #region Fields

        internal object _mapLock = new();

        private bool _creatureToMoveLock;
        private readonly List<Creature> creaturesToMove = new();

        private bool _gameObjectsToMoveLock;
        private readonly List<GameObject> _gameObjectsToMove = new();

        private bool _dynamicObjectsToMoveLock;
        private readonly List<DynamicObject> _dynamicObjectsToMove = new();

        private bool _areaTriggersToMoveLock;
        private readonly List<AreaTrigger> _areaTriggersToMove = new();

        private readonly DynamicMapTree _dynamicTree = new();

        private readonly SortedSet<RespawnInfo> _respawnTimes = new(new CompareRespawnInfo());
        private readonly Dictionary<ulong, RespawnInfo> _creatureRespawnTimesBySpawnId = new();
        private readonly Dictionary<ulong, RespawnInfo> _gameObjectRespawnTimesBySpawnId = new();
        private readonly List<uint> _toggledSpawnGroupIds = new();
        private uint _respawnCheckTimer;
        private readonly Dictionary<uint, uint> _zonePlayerCountMap = new();

        private readonly List<Transport> _transports = new();
        private readonly Grid[][] i_grids = new Grid[MapConst.MaxGrids][];
        private readonly MapRecord i_mapRecord;
        private readonly List<WorldObject> i_objectsToRemove = new();
        private readonly Dictionary<WorldObject, bool> i_objectsToSwitch = new();
        private readonly Difficulty i_spawnMode;
        private readonly List<WorldObject> i_worldObjects = new();
        protected List<WorldObject> _activeNonPlayers = new();
        protected List<Player> _activePlayers = new();
        private readonly TerrainInfo _terrain;

        private readonly MultiMap<long, ScriptAction> _scriptSchedule = new();

        private readonly BitSet marked_cells = new(MapConst.TotalCellsPerMap * MapConst.TotalCellsPerMap);
        public Dictionary<ulong, CreatureGroup> CreatureGroupHolder = new();
        internal uint i_InstanceId;
        private long i_gridExpiry;
        private bool i_scriptLock;

        public int _VisibilityNotifyPeriod;
        public float _VisibleDistance;
        internal uint _unloadTimer;

        private readonly Dictionary<uint, ZoneDynamicInfo> _zoneDynamicInfo = new();
        private readonly IntervalTimer _weatherUpdateTimer;
        private readonly Dictionary<HighGuid, ObjectGuidGenerator> _guidGenerators = new();
        private readonly SpawnedPoolData _poolData;
        private readonly Dictionary<ObjectGuid, WorldObject> _objectsStore = new();
        private readonly MultiMap<ulong, Creature> _creatureBySpawnIdStore = new();
        private readonly MultiMap<ulong, GameObject> _gameobjectBySpawnIdStore = new();
        private readonly MultiMap<ulong, AreaTrigger> _areaTriggerBySpawnIdStore = new();
        private readonly MultiMap<uint, Corpse> _corpsesByCell = new();
        private readonly Dictionary<ObjectGuid, Corpse> _corpsesByPlayer = new();
        private readonly List<Corpse> _corpseBones = new();

        private readonly List<WorldObject> _updateObjects = new();

        public delegate void FarSpellCallback(Map map);

        private readonly Queue<FarSpellCallback> _farSpellCallbacks = new();

        private readonly MultiPersonalPhaseTracker _multiPersonalPhaseTracker = new();

        private readonly Dictionary<int, int> _worldStateValues = new();

        #endregion
    }
}